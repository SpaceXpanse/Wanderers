'''Programmer’s Guide'''


Copyright (c) 2005-2010 Martin Schweiger

Copyright (c) 2022-2023 SpaceXpanse


SpaceXpanse home: [https://www.spacexpanse.org/ /www.spacexpanse.org]



= Contents =

1Spacecraft design[[#RefHeadingToc271829931|2]]

<div style="margin-left:0.3937in;margin-right:0in;">1.1Module initialisation[[#RefHeadingToc271829932|2]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.2Vessel initialisation[[#RefHeadingToc271829933|3]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.3Reading and saving a vessel state[[#RefHeadingToc271829934|3]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.4Defining class capabilities[[#RefHeadingToc271829935|4]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.5Creating rocket engines[[#RefHeadingToc271829936|5]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.6Air-breathing engines[[#RefHeadingToc271829937|11]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.7Rendering re-entry flames[[#RefHeadingToc271829938|14]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.8Adding particle streams for exhaust and reentry effects[[#RefHeadingToc271829939|15]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.9Atmospheric flight model[[#RefHeadingToc271829940|17]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.10Defining an animation sequence[[#RefHeadingToc271829941|21]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.11Designing 2D-instrument panels[[#RefHeadingToc271829942|24]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.12Designing instrument panels (legacy style)[[#RefHeadingToc271829943|29]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">1.13Designing virtual cockpits[[#RefHeadingToc271829944|38]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">'''2Planets and moons[[#RefHeadingToc271829945|45]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">2.1Planet texture maps[[#RefHeadingToc271829946|45]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">2.2Planet modules[[#RefHeadingToc271829947|48]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">2.3Defining an atmosphere[[#RefHeadingToc271829948|51]]</div>

<div style="margin-left:0.3937in;margin-right:0in;">'''3References[[#RefHeadingToc271829949|60]]</div>

= {{anchor|RefHeadingToc271829931}} Spacecraft design =

This section describes how to create a new ''vessel class'' for SpaceXpanse by writing a ''vessel DLL module''. Although it is possible to create simple vessel classes by writing a vessel configura­tion file without a custom module, the full potential of SpaceXpanse’s custom spacecraft design ca­pabilities can only be realised with a specialised module.


{| style="border-spacing:0;width:6.4979in;"
|-
| style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | [[Image:Image1.png|top]][[Image:Image2.png|top]]
| style="border:0.5pt solid #ff0000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | All vessels of a given class share the same DLL module. SpaceXpanse only loads a single in­stance of the DLL. This means that global variables are shared between all vessels of that class. Do not store data which are specific to individual vessels in global or static variables, because they can be overwritten by another vessel.


|-
|}
== {{anchor|RefHeadingToc271829932}} Module initialisation ==

When the user launches the simulation by picking a scenario from the SpaceXpanse Launchpad dialog and pressing the “Launch SpaceXpanse” button, SpaceXpanse will load the vessel DLL module for each spacecraft type used in the simulation, and call its ''Init­Module'' function. This function is called only once per SpaceXpanse session, no matter how many spacecraft of that type appear in the simulation. It will not be called again if the user exits the simulation to the Launchpad, and reloads another simulation scenario. You can use it to initialise global (non-instance specific and non-session specific) pa­rameters.

<nowiki>#define SpaceXpanse_MODULE</nowiki>

<nowiki>#include "SpaceXpansesdk.h"</nowiki>


HINSTANCE g_hDLL;


DLLCLBK void InitModule (HINSTANCE hModule)

{

g_hDLL = hModule;

<div style="color:#808080;">// perform global module initialisation here</div>

}

In this example, we use the ''InitModule'' function to save the module instance handle passed to the function in global variable ''g_hDLL''. This handle is useful later, e.g. when load­ing resources stored in the module file. Note the first line of the code ex­ample, which defines the ''SpaceXpanse_MODULE'' flag. This flag should be included in all SpaceXpanse DLL modules, to ensure proper execution of initialisation and cleanup func­tions.

At the end of a simulation run, SpaceXpanse calls the ''ExitModule'' function for each DLL module.

DLLCLBK void ExitModule (HINSTANCE hModule)

{

<span style="color:#808080;">// perform module cleanup here</span>

}

If you performed any dynamic memory allocation in ''InitModule'', this is a good place to perform the corresponding cleanup operations which de-allocate that memory.

== {{anchor|Ref84709707}} {{anchor|RefHeadingToc271829933}} Vessel initialisation ==

To allow initialisation of individual spacecraft, SpaceXpanse will call the ovcInit function each time a scenario is loaded, for each vessel of that type listed in the scenario file. SpaceXpanse will also call ''ovcInit'' during the simulation if a new vessel of this type is cre­ated. The main purpose of ovcInit is to create an instance of a ''VESSEL''-derived in­terface class. ''VESSEL'' is a class de­fined in the SpaceXpanse API which is the primary means of communication between SpaceXpanse and your own spacecraft class. In order to make use of the interface, you should derive your own vessel class derived from ''VESSEL''. In ''ovcInit'', you then create an instance of that class and return it back to SpaceXpanse. Note that in the latest SpaceXpanse version, the new ''VESSEL2'' class has been in­troduced which inherits all the methods of ''VESSEL'', and introduces a number of new callback functions which replace the previous method of event notification. You should derive your vessel class from ''VESSEL2'' to make use of this latest interface.

As an example, let’s create a new class called ''MyVessel'', and create an instance in ''ovcInit'':

class MyVessel: public VESSEL2 {

public:

MyVessel (OBJHANDLE hObj, int fmodel): VESSEL2 (hObj, fmodel) {}

~MyVessel () {}

<div style="color:#808080;">// add more vessel methods here</div>

};


DLLCLBK VESSEL *ovcInit (OBJHANDLE hvessel, int flightmodel)

{

return new MyVessel (hvessel, flightmodel);

}

''ovcInit'' passes two parameters to your module: a handle to the vessel for which you are about to create an interface, and a flag for the type of flight model requested by the user. Both parameters are passed on to the vessel constructor. The vessel handle is required to identify your vessel when requesting information from SpaceXpanse. The ''flightmodel'' flag can be used to im­plement different behaviour in your module, for ex­ample to define an “easy” and a “complex” flight model, which can then be selected by the user. You don’t need to store these parame­ters in your module, because you can retrieve them with the ''GetHandle'' and ''GetFlight­Model'' methods of the ''VESSEL'' class.

To ensure proper cleanup at the end of a simulation session, you must implement the ''ovcExit'' function to delete your vessel:

DLLCLBK void ovcExit (VESSEL *vessel)

{

if (vessel) delete (MyVessel*)vessel;

}

Note that you need to cast the generic ''VESSEL'' pointer passed by SpaceXpanse to your own vessel class to ensure that the correct destructors are called.

== {{anchor|RefHeadingToc271829934}} Reading and saving a vessel state ==

Next, you need to make sure that your vessel is able to read its initial state from a scenario file at the start of a simulation, and to save its state in a scenario at the end of the simulation. This is done by overloading the ''clbkLoadStateEx'' and ''clbkSave­State'' methods of the ''VESSEL2'' class. Note that you only need to overload these methods if your vessel requires nonstandard parameters to be stored in the scenario file. Standard parameters (such as posi­tion or velocity) are automatically read and written by the base class methods.

class MyVessel: public VESSEL2 {

public:

MyVessel (OBJHANDLE hObj, int fmodel): VESSEL2 (hObj, fmodel) {}

~MyVessel () {}

void clbkLoadStateEx (FILEHANDLE scn, void *status);

void clbkSaveState (FILEHANDLE scn);

private:

double myparam;

};


void MyVessel::clbkLoadStateEx (FILEHANDLE scn, void *status)

{

char *line;


while (oapiReadScenario_nextline (scn, line)) {

if (!strnicmp (line, "MYPARAM", 7)) {

sscanf (line+7, "%lf", &myparam);

} else {

ParseScenarioLineEx (line, status);

}

}

}


void MyVessel::clbkSaveState (FILEHANDLE scn)

{

VESSEL2::clbkSaveState (scn);

oapiWriteScenario_float (scn, "MYPARAM", myparam);

}

In the code fragment above, we use the overloaded ''clbkLoadStateEx'' function to read my­param from the scenario, were it is stored under the ''MYPARAM'' label. The func­tion reads each line of the scenario file associated with our vessel, using the ''oapiReadSce­nario_nextline'' function. In the loop, we process the ''MYPARAM'' line, and pass everything else to SpaceXpanse via ''ParseScenarioLineEx'' for default processing. Likewise, in ''clbkSaveState'', the base class method ''VESSEL2::clbkSaveState'' is called to store all default parameters, before writing our private ''MYPARAM'' value. Of course, a real vessel implementation may need to store a large number of pa­rameters in the scenario to make sure its status is completely defined when the scenario is loaded next time.

== {{anchor|RefHeadingToc271829935}} Defining class capabilities ==

One of the most important callback functions that should be overloaded is the ''clbkSetClassCaps'' method. It defines the general capabilities and properties of your spacecraft, e.g. its mass, size, visual representation, engine layout etc.

void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

SetEmptyMass (1000.0);

SetSize (10.0);

AddMesh (oapiLoadMeshGlobal (“MyVessel.msh”));

// define vessel capabilities here

}

In the above example, we define a few essential parameters (empty mass and mean radius), and load a mesh to provide a visual representation for our new spacecraft class. In practical applications, many more parameters may have to be defined here. Note that the file handle passed to the function points to the configuration file (.cfg) of the vessel. This can be used to read parameters from the file, thereby al­lowing the user to overwrite parameters by editing the configuration file.

We now have a “skeleton implementation” for our new spacecraft class. To make it interesting, many more properties need to be defined, such as rocket engines (or air-breathing engines), aerodynamic properties, animations, etc. Some of these aspects are described in the rest of this chapter. For a com­plete (and sometimes quite com­plex) vessel implementations, see the sample projects in the ''SpaceXpansesdk\samples'' sub­directory.

== {{anchor|RefHeadingToc271829936}} Creating rocket engines ==

To propel your ship in space, you must equip it with engines. There exist a variety of different rocket engine types, such as liquid and solid fuel engines, or more futuristic ones such as ion or photon drives.

=== A bit of theory ===

= Thrust force =

Despite their very different design, all engines work by the same principle: generating a thrust force in one direction by expelling particles in the opposite direction at high velocity. A liquid-fuel engine, for example, consists of a burn chamber in which a mixture of propellant and oxydiser are ignited, and a nozzle through which the ex­panding gas is forced at high velocity. The force ''F<sub>th''</sub> generated by the engine is pro­portional to the propellant mass flow dm/dt and the velocity ''v''<sub>0</sub> of the expelled gas:

<div style="text-align:center;"><math>{\vec{F}}_{\text{th}}=\frac{\text{dm}}{\text{dt}}\left(t\right){\vec{v}}_{0}</math></div>

When creating a thruster, you need to specify the maximum force ''F<sub>th''</sub> it can generate when it is driven at full power, and the propellant exit velocity ''v''<sub>0</sub>. (in SpaceXpanse, ''v''<sub>0</sub> is called the ''fuel-specific impulse'', or Isp). The Isp value determines how much fuel per second is consumed to obtain a given thrust force. The higher the Isp value, the more fuel-efficient the engine.


<div style="text-align:center;">[[Image:Object2.png|top]]</div>


Sometimes the ''thrust-specific fuel consumption'' (TSFC) is quoted in the literature. This is the amount of propellant that needs to be burned per second to obtain 1N of thrust. Thus the TSFC is the inverse of the Isp and has units of [s m<sup>-1</sup>], or more intui­tively [kg s<sup>-1</sup> N<sup>-1</sup>].

'''Note:''' In SpaceXpanse, the thrust is specified as a force, and has units of Newton [1N = 1kg m s<sup>-2</sup>]. In the literature, thrust is often specified in units of kg. To convert such data into SpaceXpanse units, multiply by 1g = 9.81 m s<sup>-2</sup>. Isp is specified as a velocity in SpaceXpanse, with units of m s<sup>-1</sup>. In the literature it is often given in units of seconds [s]. To convert to SpaceXpanse units, again multiply by 1g.

'''How long will my fuel last?'''

The burn time ''T<sub>b''</sub> at full thrust ''F<sub>max''</sub> for fuel mass ''m<sub>F''</sub> is given by

<div style="text-align:center;"><math>{T}_{b}=\frac{{m}_{F}\text{Isp}}{{F}_{\text{max}}}</math></div>

= Pressure-dependent thrust efficiency =

Most conventional rocket engines work less efficiently in the presence of ambient at­mospheric pressure, because the ignited gas must be expelled through the nozzle against the outside pressure of the atmosphere. This leads to a reduction of the thrust force at ambient pressure ''p'':

<div style="text-align:center;"><math>F(p)={F}_{0}-\text{pA}</math></div>

where ''F''<sub>0</sub> is the vacuum thrust rating and ''A'' has units of an area [m<sup>2</sup>] and can be re­garded as the ''effective nozzle cross section''. If we know the force ''F''<sub>1</sub> generated at am­bient pressure ''p''<sub>1</sub>, then

<div style="text-align:center;"><math>{F}_{1}={F}_{0}-{p}_{1}A\phantom{\rule{2em}{0ex}}\Rightarrow \phantom{\rule{2em}{0ex}}A=\frac{{F}_{0}-{F}_{1}}{{p}_{1}}</math></div>

and therefore

<div style="text-align:center;"><math>F\left(p)={F}_{0}-p\frac{{F}_{0}-{F}_{1}}{{p}_{1}}={F}_{0}\left(1-p\frac{{F}_{0}-{F}_{1}}{{F}_{0}{p}_{1}}\right)={F}_{0}\right(1-\mathit{p\eta })</math></div>

and likewise

<div style="text-align:center;"><math>\text{Isp}\left(p)={\text{Isp}}_{0}\right(1-\mathit{p\eta })</math></div>

In the literature, the pressure-dependency of engine thrust is often defined by speci­fying the Isp value for both vacuum and a given reference pressure (e.g. atmospheric pressure at sea level). SpaceXpanse uses the same convention to apply pressure depend­ency.

= Thrust level =

In SpaceXpanse, thrusters can be driven at any level ''L'' between 0 (cutout) and 1 (full thrust). The actual thrust force generated by the engine is thus calculated as

<div style="text-align:center;"><math>F\left(p)={F}_{\text{max}}\right(p)\cdot L</math></div>

In reality, thrusters can often only be driven at maximum, or within a limited range below maximum. This is not currently implemented in SpaceXpanse, but may be intro­duced in a future version.

= Thruster placement and thrust direction =

The effect of a thruster depends on its placement on the vessel, and the direction in which the thrust force is generated. In the most general case, a thruster will produce both a linear acceleration (due to a force) and an angular acceleration (do to torque).

Torque is generated if the force vector does not pass through the vessel’s centre of gravity (CG)

<div style="text-align:center;">[[Image:Object9.png|top]]</div>


The torque is then given by the cross product

<div style="text-align:center;"><math>\vec{M}=\vec{F}\times \vec{r}</math></div>

(remember that SpaceXpanse uses a left-handed coordinate system!) To avoid uncontrolla­ble spin you should design your ship’s main engines so that their force vector passes through the CG. Vessel coordinates are always defined so that the CG is at the origin (0,0,0). Therefore, a thruster located at (0,0,-10) and generating thrust in direction (0,0,1) would not generate torque.

'''Attitude thrusters: Rotation'''

Sometimes generating torque is desired in order to rotate the spacecraft. For con­trolled attitude manouevres one then usually wants to change ''only'' the angular mo­ment, without also inducing a linear acceleration. This requires the simultaneous op­eration of at least 2 thrusters so that their linear moments cancel.

<div style="text-align:center;">[[Image:Object11.png|top]]</div>


'''Attitude thrusters: Translation'''

In order to provide small linear accelerations in various directions (for example, to line the ship up with the docking port of a space station), thrusters must be driven single or in groups so that they don’t generate torque. Sometimes it is possible to re-use the rotational attitude thrusters for this task, but it is equally possible to add separate linear thrusters.

<div style="text-align:center;">[[Image:Object12.png|top]]</div>


'''Engine gimbal and thrust vectoring'''

Using attitude thrusters in a launch vehicle during the burn phase of the main en­gines is usually not practical. Instead, attitude control is performed by tilting the main engines and thereby generating a torque as described above. In practice this may be done by suspending the engines in a gimbal system which allows rotation around one or two axes. In SpaceXpanse, this can be implemented by modifying the thrust direction of the engine.

Another way to change the thrust direction is by inserting deflector plates into the exhaust stream.

'''Torque, angular momentum and angular velocity'''

The relationship between torque M and angular velocity is given by Euler’s equations for a rotating rigid body:

<div style="text-align:center;"><math>\begin{array}{c}{J}_{x}{\dot{\omega }}_{x}={M}_{x}-({J}_{z}-{J}_{y}){\omega }_{y}{\omega }_{z}\\ 
{J}_{y}{\dot{\omega }}_{y}={M}_{y}-({J}_{x}-{J}_{z}){\omega }_{z}{\omega }_{x}\\ 
{J}_{z}{\dot{\omega }}_{z}={M}_{z}-({J}_{y}-{J}_{x}){\omega }_{x}{\omega }_{y}\end{array}</math></div>

where (''J<sub>x</sub>, J<sub>y</sub>, J<sub>z''</sub>) are the principal moments of the inertia tensor (PMI), (''M<sub>x</sub>, M<sub>y</sub>, M<sub>z''</sub>) are the components of the torque tensor, and (''<sub>x</sub>, <sub>y</sub>, <sub>z''</sub>) are the angular velocity components around the x, y, and z-axes. In SpaceXpanse, this system of differential equa­tions is solved by a trapezoid rule.

=== Putting it all into the module ===

Now that you know how thrusters work, it is time to add a few to your new ship. As with other vessel capabilities, thrusters should usually be designed in the ''clbkSet­ClassCaps'' callback function, for example like this (assuming that ''MyVessel'' is a class derived from ''VESSEL2''):

void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

// vessel caps definitions

}

'''Propellant resources'''

Thrusters can only be operated if they are connected to propellant resources (e.g. fuel tanks). To create a propellant resource:

class MyVessel: public VESSEL

{

...

PROPELLANT_HANDLE ph_main;

}


void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

...

const double MAX_MAIN_FUEL = 1e5;

ph_main = CreatePropellantResource (MAX_MAIN_FUEL);

...

}

which creates a fuel tank of capacity 10<sup>5</sup>kg. ''CreatePropellantResource'' returns a han­dle to the new tank, which is used later to connect thrusters to the tank.

''CreatePropellantResource'' accepts two further optional parameters: the initial fuel mass, and a fuel efficiency factor ''eff'' between 0 and 1. By default, the tank is full, with fuel efficiency 1. If an ''eff'' < 1 is specified, then the thrust force generated by all con­nected thrusters is modified by

<div style="text-align:center;"><math>{F}^{\text{'}}=F\cdot \text{eff}</math></div>

'''Creating thrusters'''

To add a new thruster, use the ''CreateThruster'' command:

class MyVessel: public VESSEL

{

...

THRUSTER_HANDLE th_main;

}


void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

...

const double MAX_MAIN_THRUST = 2e5;

const double VAC_MAIN_ISP = 4200.0;

th_main = CreateThruster (_V(0,0,-8), _V(0,0,1), MAX_MAIN_THRUST,

ph_main, VAC_MAIN_ISP);

...

}

This adds a thruster at position (0,0,-8) with a thrust vector in the positive z-direc­tion, with the specified max. thrust and Isp values, and connected to the tank we added earlier. In this configuration, the engine efficiency is assumed not to be af­fected by atmospheric pressure. For increased realism, we could introduce pressure-dependency by adding an additional Isp value at a reference pressure, and the refer­ence pressure itself:

void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

...

const double MAX_MAIN_THRUST = 2e5;

const double VAC_MAIN_ISP = 4200.0;

const double NML_MAIN_ISP = 3500.0;

const double P_NML = 101.4e3;

th_main = CreateThruster (_V(0,0,-8), _V(0,0,1), MAX_MAIN_THRUST,

ph_main, VAC_MAIN_ISP, NML_MAIN_ISP, P_NML);

...

}

This reduces the Isp value at sea level to 3500 and performs a linear interpolation to obtain the Isp at arbitrary pressures. Note that we could have omitted the last pa­rameter, ''P_NML'', because the reference pressure defaults to 101.4 kPa (atmospheric pressure at Earth sea level).

If you descend into a very dense planetary atmosphere, SpaceXpanse will extrapolate the Isp value beyond sea level pressure, until Isp drops to zero. At this point, the thruster will stop working altogether.

'''Grouping thrusters'''

Although it is possible to address thrusters individually in your module, it is often easier to engage them in groups. Groups are also required to activate manual user thruster control via the keyboard or joystick, and the automatic navigation modes such as ''killrot''.

SpaceXpanse has a number of standard thruster groups, such as ''THGROUP_MAIN'', ''THGROUP_RETRO'', ''THGROUP_HOVER'', and a full set of attitude thruster groups. For a full listing, see ''VESSEL::CreateThrusterGroup'' in the Reference Manual.

It is the responsibility of the vessel designer to make sure that thrusters are grouped in a sensible way. For example, whenever the user presses the “+” key on the numeri­cal keypad, all thrusters in ''THGROUP_MAIN'' will fire. If the thrusters grouped in ''THGROUP_MAIN'' behave in an unexpected or non-intuitive way it will be confusing to the user. Furthermore, if attitude thrusters are not appropriately grouped, some or all of the navigation modes may fail.

To group thrusters, use the ''CreateThrusterGroup'' command:

void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

...

thg_main = CreateThrusterGroup (th_main, 2, THGROUP_MAIN);

...

}

(this assumes that ''th_main'' is an array of 2 thruster handles which have been created previously). The function returns a handle to the group which can be used later to address the group.

Apart from the standard groups, SpaceXpanse allows to create custom groups by using the ''THGROUP_USER'' label. Custom groups are not engaged by any of the standard manual or automatic control methods, therefore the module must implement a suit­able control interface for these groups.

=== Defining exhaust flames ===

When you define a thruster with ''CreateThruster'', SpaceXpanse will not automatically gen­erate visuals for the exhaust flames when the thruster is engaged. Sometimes exhaust flames may not be appropriate, or, more importantly, you may want to detach the ''logical'' thruster definition from the ''physical'' definition (more about this below).

To create an exhaust flame definition use the ''AddExhaust'' function. ''AddExhaust'' comes in two flavours:* ''UINT AddExhaust (THRUSTER_HANDLE th, double lscale, double wscale, SURFHANDLE tex = 0) const''
* ''UINT AddExhaust (THRUSTER_HANDLE th, double lscale, double wscale, const VECTOR3 &pos, const VECTOR3 &dir, SURFHANDLE tex = 0) const''



Both versions require a handle to the logical thruster they are linked to, and two size parameters (longitudinal and transversal scaling), but while the first version takes exhaust location and direction directly from the thruster definition, the second ver­sion gets location and direction passed as parameters.

Here is an example demonstrating how you would use the second version of ''AddEx­haust'':

Let’s assume you build a rocket propelled by 4 main engines arranged in a regular square pattern. The engines have fixed orientation (no individual gimbal mode) and all thrust force vectors are parallel. In addition, the engines produce identical thrust magnitudes at all times.

Then the 4 engines can be represented by a single logical thruster, whose magnitude is the sum of the 4 actual engines, and positioned in the geometric centre. This sim­plifies the code, and is more efficient, because SpaceXpanse does not need to add up 4 indi­vidual force vectors.

However, you still want to see exhaust flames for each of the 4 engines, so you would use the second version of ''AddExhaust'' to define 4 exhaust flames at the correct posi­tions.

The disadvantage of the second version is that changes in the position or orientation of the thruster (for example as a result of ''SetThrusterPos'' or ''SetThrusterDir'') are not automatically propagated to the exhaust flames. Therefore, if you plan to move or tilt the thrusters, you should create them individually and use the first version of ''AddEx­haust''.

'''Custom exhaust textures'''

By default, SpaceXpanse uses a standard texture to render exhaust flames. If you want to customise the exhaust appearance on a per-thruster basis, you can pass a nonzero surface handle tex to both of the ''AddExhaust'' versions. To obtain a surface handle for a custom texture, use the ''oapiRegisterExhaustTexture'' function.

...

SURFHANDLE tex = oapiRegisterExhaustTexture (“MyExhaust”);

AddExhaust (th_main, 10, 2, tex);

...

The texture file must be stored in DDS format in SpaceXpanse’s default texture directory. Note that ''oapiRegisterExhaustTexture'' can be safely called multiple times with the same texture.

== {{anchor|RefHeadingToc271829937}} Air-breathing engines ==

SpaceXpanse is not limited to rocket engines. Other devices for generating thrust can be imple­mented as well, from turbojet engines to solar sails or some hypothetical future technology. Unlike conventional rocket engines, which are natively supported by the SpaceXpanse core, custom designs require a bit more work from the developer. As an ex­ample, I will here discuss the (tentative) scramjet engine implementation used by the Space Cruiser.

A ramjet engine is a type of a jet engine which compresses the air for combustion not by any mechanical rotating machinery, but simply by “ramming” through the atmos­phere, i.e. by us­ing the aircraft’s velocity in the airstream. This is an efficient way of generating thrust at su­personic speeds, but does not work at very low speed. (A scramjet is a variant where the air is not slowed down to subsonic speeds in the com­bustor and therefore avoids excessive heating at extreme velocities).

A typical ramjet engine is composed of 3 sections:* the inlet diffuser where the air is isentropically decelerated, with pressure increas­ing from freestream pressure ''p''<sub></sub> to ''p<sub>d''</sub>, and temperature increasing from freestream temperature ''T''<sub></sub> to ''T<sub>d''</sub>.
* the combustion chamber, where the air-fuel mixture is burned at constant pres­sure ''p<sub>b''</sub> = ''p<sub>d''</sub>, and temperature increases from ''T<sub>d''</sub> to ''T<sub>b''</sub>.
* the exhaust nozzle, where the hot, high-pressure gas is expanded isentropically, with pressure decreasing from ''p<sub>b''</sub> to ''p''<sub></sub>, and temperature decreasing from ''T<sub>b''</sub> to ''T<sub>e''</sub>.



The temperatures and pressures in the three parts of the engine (diffuser, burner and exhaust) can be calculated in the following form:

<div style="text-align:center;"><math>\begin{array}{cc}{T}_{d}={T}_{\mathrm{\infty }}\left(1+\frac{\gamma -1}{2}{M}_{\mathrm{\infty }}^{2}\right)& 	{p}_{d}={p}_{\mathrm{\infty }}{\left(\frac{{T}_{d}}{{T}_{\mathrm{\infty }}}\right)}^{\gamma /(\gamma -1)}\\ 
{T}_{b}=\text{max}\left({T}_{b0},{T}_{d}\right)& 	{p}_{b}={p}_{d}\\ 
{T}_{e}={T}_{b}{\left(\frac{{p}_{e}}{{p}_{b}}\right)}^{(\gamma -1)/\gamma }& 	{p}_{e}={p}_{\mathrm{\infty }}\end{array}</math></div>

where ''M''<sub></sub> is the freestream Mach number, '''' is the ratio of specific heats, and ''T<sub>b''0</sub> is the burner temperature limit, an engine design parameter defined by the heat resistance of the combustion chamber material. Note that if at high velocities ''T<sub>d''</sub> > ''T<sub>b''0</sub>, the engine will start to overheat purely from the isentropic compression in the diffuser, without any combustion taking place! The figure below shows an example for the temperature distribution in the engine compartments as a function of freestream Mach number. The example assumes a burner temperature limit of ''T<sub>b''0</sub> = 3200 K. In this case, the limiting velocity is ''v'' = Mach 8.2.

<div style="text-align:center;">[[Image:Image3.png|top]]</div>

To calculate the thrust generated by a scramjet, we start from the fundamental thrust equation for jet propulsion,

<div style="text-align:center;"><math>F=({\dot{m}}_{a}+{\dot{m}}_{f}\left){v}_{e}-{\dot{m}}_{a}{v}_{\mathrm{\infty }}+({p}_{e}-{p}_{\mathrm{\infty }}\right){A}_{e}</math></div>

where <math>{\dot{m}}_{a}</math>and <math>{\dot{m}}_{f}</math>are the air and fuel mass rates, respectively (using the common nota­tion <math>\dot{x}=\text{dx}/\text{dt}</math>), <math>{v}_{e}</math>and <math>{v}_{\mathrm{\infty }}</math>are the exhaust and freestream velocities, and <math>{A}_{e}</math>is the exhaust cross section. 

Because of the assumption ''p<sub>e''</sub> = ''p''<sub></sub> the last term vanishes. The ''specific thrust'' is then given by

<div style="text-align:center;"><math>\frac{F}{{\dot{m}}_{a}}=\left(1+D\right){v}_{e}-{v}_{\mathrm{\infty }}</math></div>

where <math>D={\dot{m}}_{f}/{\dot{m}}_{a}</math>is the ''fuel-to-air ratio''.

The amount of fuel burned in the combustion chamber must be adjusted so that the burner temperature limit is not exceeded. This leads to the following expression for ''D'':

<div style="text-align:center;"><math>D=\frac{{T}_{b}-{T}_{d}}{Q/{c}_{p}-{T}_{b}}</math></div>

where ''Q'' is a fuel-specific heating value and ''c<sub>p''</sub> is the specific heat at constant pres­sure, given by

<div style="text-align:center;"><math>{c}_{p}=\frac{\mathit{\gamma R}}{\gamma -1}</math></div>

The mass flow of air collected by the engine is a function of air intake cross section ''A<sub>i''</sub>, freestream density ''''<sub></sub> and freestream velocity ''v''<sub></sub>:

<div style="text-align:center;"><math>{\dot{m}}_{a}={\rho }_{\mathrm{\infty }}{v}_{\mathrm{\infty }}{A}_{i}</math></div>

where ''v''<sub></sub> can be expressed in terms of the freestream Mach number:

<div style="text-align:center;"><math>{v}_{\mathrm{\infty }}={M}_{\mathrm{\infty }}\sqrt{\gamma {\text{RT}}_{\mathrm{\infty }}}</math></div>

From the above equations for ''D'' and <math>{\dot{m}}_{a}</math>we can calculate the fuel rate <math>{\dot{m}}_{f}</math>required to achieve combustion temperature ''T<sub>b''</sub>.


The final quantity required to calculate ''F'' is the exhaust velocity <math>{v}_{e}</math>. This can be ob­tained from the energy balance

<div style="text-align:center;"><math>{c}_{p}{T}_{b}={c}_{p}{T}_{e}+{v}_{e}^{2}/2</math></div>

We now have all the components to calculate the thrust ''F'' generated by the engine. The graphs below show various scramjet parameters for velocities in the range from Mach 0 to Mach 10 at an altitude of 10 km (assuming ''''<sub></sub> = 0.43 kg/m<sup>3</sup> and ''T''<sub></sub> = 225 K). The SC engine design parameters in this example are ''Q'' = 4.5  10<sup>7</sup> J/kg, ''A<sub>i''</sub> = 0.6 m<sup>2</sup>, and ''T<sub>b''0</sub> = 3200 K.

[[Image:Image4.png|top]][[Image:Image5.png|top]]

[[Image:Image6.png|top]][[Image:Image7.png|top]]

== {{anchor|RefHeadingToc271829938}} Rendering re-entry flames ==

To visualise the friction heat dissipation during atmospheric reentry, SpaceXpanse sup­ports the rendering of “re-entry flames”. To calculate the amount of heat generated per surface area and time (and to scale the exhaust flames) SpaceXpanse uses this formula:

<div style="text-align:center;"><math>P=\frac{1}{2}{\mathit{\rho v}}^{3}</math></div>

where '''' is the atmospheric density, and ''v'' is the vessel’s airspeed. SpaceXpanse renders ex­haust flames if ''P'' > ''P''<sub>0</sub> where ''P''<sub>0</sub> is a user defined limit. The size and opacity of the re­entry flames is scaled by

<div style="text-align:center;"><math>s=\text{min}\left(1,\frac{P-{P}_{0}}{5{P}_{0}}\right)</math></div>

In addition, the user can specify scaling factors for length and width of the reentry texture, as well as the texture itself.

SpaceXpanse by default uses its own texture to render reentry flames. If you want to change the texture globally, you need to replace reentry.dds in the Textures subdirectory. If you only want to modify the texture for a specific vessel class, you need to load a custom texture, and then set your render options:

void MyVessel::clbkSetClassCaps (FILEHANDLE cfg)

{

...

SURFHANDLE tex = oapiRegisterReentryTexture (“MyReentryFlame”);

SetReentryTexture (tex, my_plimit, my_lscale, my_wscale);

...

}

Reentry textures require a specific layout. They consist of an elongated part in the left half of the texture map, and a circular part in the upper right corner. The lower right corner is not currently used. This is how the alpha channel of the default reentry.dds looks like:

<div style="text-align:center;">[[Image:Image8.png|top]]</div>

Note that SpaceXpanse automatically adds a colour component to the texture depending on the value of ''s'', from red to white. If this is sufficient for your custom reentry flame, leave the RGB channels of the texture pure white. Otherwise you may want to ex­periment with additional texture colours.

If you want to suppress rendering of reentry flames for your vessel altogether, use

...

SetReentryTexture (NULL);

...

== {{anchor|Ref9705334}} {{anchor|RefHeadingToc271829939}} Adding particle streams for exhaust and reentry effects ==

SpaceXpanse supports ''particle streams'' for rendering contrails, exhaust gases, reentry plasma trails etc. Particle streams consist of a series of textured “billboard” objects which always face the camera. The streams can be customised with a set of parame­ters and allow the simulation of a variety of effects.

===== The PARTICLESTREAMSPEC structure =====

At creation, the particle stream can be customised by passing a ''PARTI­CLESTREAMSPEC'' structure to ''VESSEL::AddExhaustStream'' and ''VES­SEL::AddReentryStream''. The structure is defined as follows:

typedef struct {

DWORD flags;

double srcsize;

double srcrate;

double v0;

double srcspread;

double lifetime;

double growthrate;

double atmslowdown;

enum LTYPE { EMISSIVE, DIFFUSE } ltype;

enum LEVELMAP { LVL_FLAT, LVL_LIN, LVL_SQRT, LVL_PLIN, LVL_PSQRT }

levelmap;

double lmin, lmax;

enum ATMSMAP { ATM_FLAT, ATM_PLIN } atmsmap;

double amin, amax;

SURFHANDLE tex;

} PARTICLESTREAMSPEC;

''srcrate''

<div style="margin-left:0.3937in;margin-right:0in;">The (average) rate at which particles are created by the emission source [Hz].</div>

''v0''

<div style="margin-left:0.3937in;margin-right:0in;">The (average) emission velocity of particles by the emission source [m/s]</div>

''ltype''

<div style="margin-left:0.3937in;margin-right:0in;">Defines the material lighting method when rendering the particles.</div>

<div style="margin-left:1.2799in;margin-right:0in;">''EMISSIVE'':Particles are rendered emissive (self-radiating). This is appropri­ate for streams representing ionized exhaust gases, or plasma streams during reentry.</div>

<div style="margin-left:1.2799in;margin-right:0in;">''DIFFUSE'':Particles are rendered diffuse (diffuse reflection of external light sources). This is appropriate for smoke and vapour trails.</div>

''levelmap''

<div style="margin-left:0.3937in;margin-right:0in;">Defines the mapping between the level parameter ''L'' (e.g. thruster level) and the alpha value '''' (opacity) of the generated particle. The higher the alpha value, the more solid the stream will appear. This parameter is only used for exhaust streams. The following options are available:</div>

<div style="margin-left:1.2799in;margin-right:0in;">''LVL_FLAT'':constant mapping, i.e. alpha is independent of th reference level: '''' = lmin</div>

<div style="margin-left:1.2799in;margin-right:0in;">''LVL_LIN'':linear mapping: '''' <nowiki>= </nowiki>''L''</div>

<div style="margin-left:1.2799in;margin-right:0in;">''LVL_SQRT'':square root mapping: <math>\alpha =\sqrt{L}</math></div>

<div style="margin-left:1.2799in;margin-right:0in;">''LVL_PLIN'':linear mapping in sub-range: <math>\alpha =\lbrace \begin{array}{cc}0& 	\text{if}\phantom{\rule{0.5em}{0ex}}L< \text{lmin}\\ 
\frac{L-\text{lmin}}{\text{lmax}-\text{lmin}}& 	\text{if}\phantom{\rule{0.5em}{0ex}}\text{lmin}\le L\le \text{lmax}\\ 
1& 	\text{if L}> \text{lmax}\end{array}</math></div>

<div style="margin-left:1.2799in;margin-right:0in;">''LVL_PSQRT'': square root mapping in sub-range: <math>\alpha =\lbrace \begin{array}{cc}0& 	\text{if}\phantom{\rule{0.5em}{0ex}}L< \text{lmin}\\ 
\sqrt{\frac{L-\text{lmin}}{\text{lmax}-\text{lmin}}}& 	\text{if}\phantom{\rule{0.5em}{0ex}}\text{lmin}\le L\le \text{lmax}\\ 
1& 	\text{if L}> \text{lmax}\end{array}</math></div>

''lmin, lmax''

<div style="margin-left:0.3937in;margin-right:0in;">Defines min and max levels for alpha mapping. Only used if ''levelmap'' is ''CONST'', ''PLIN'' or ''PSQRT'' (see above). For ''CONST'', only ''lmin'' is used. For ''PLIN'' and ''PSQRT'', ''lmin'' < ''lmax'' is required. Note that ''lmin'' < 0 is valid – this will cause the stream to produce particles even when the reference level is 0. Likewise, ''lmax'' > 1 is valid – this will cause the alpha value of the particles to remain < 1 even at reference level 1.</div>

''atmsmap''

<div style="margin-left:0.3937in;margin-right:0in;">Defines the mapping between atmospheric parameters and the alpha value '''' (opacity) of the generated particle. The following options are available:</div>

<div style="margin-left:0.8862in;margin-right:0in;">''ATM_FLAT'':constant mapping, i.e. alpha is independent of atmospheric pa­rameters: '''' = amin</div>

<div style="margin-left:0.8862in;margin-right:0in;">''ATM_PLIN'':linear mapping of ambient atmospheric parameter ''x'': <math>\alpha =\lbrace \begin{array}{cc}0& 	\text{if}\phantom{\rule{0.5em}{0ex}}x< \text{amin}\\ 
\frac{x-\text{amin}}{\text{amax}-\text{amin}}& 	\text{if}\phantom{\rule{0.5em}{0ex}}\text{amin}\le x\le \text{amax}\\ 
1& 	\text{if x}> \text{amax}\end{array}</math></div>

<div style="margin-left:0.8862in;margin-right:0in;">''ATM_PLOG'':logarithmic mapping of ambient atmospheric parameter ''x'': <math>\alpha =\lbrace \begin{array}{cc}0& 	\text{if}\phantom{\rule{0.5em}{0ex}}x< \text{amin}\\ 
\frac{\text{ln}x/\text{amin}}{\text{ln}\text{amax}/\text{amin}}& 	\text{if}\phantom{\rule{0.5em}{0ex}}\text{amin}\le x\le \text{amax}\\ 
1& 	\text{if x}> \text{amax}\end{array}</math></div>

<div style="margin-left:0.3937in;margin-right:0in;">For exhaust streams, atmospheric parameter ''x'' is the ambient atmospheric den­sity, ''''. For reentry streams, ''x'' is defined as <math>x=\frac{1}{2}{\mathit{\rho v}}^{3}</math>(''v'': airspeed) which is propor­tional to the friction power in turbulent airflow (omitting geometry-re­lated parameters).</div>

''amin, amax''

<div style="margin-left:0.3937in;margin-right:0in;">Defines min and max atmospheric parameter (ambient density or friction power) for alpha mapping. ''amin'' < ''amax'' is required. For ''PLIN'', ''amin'' < 0 is ad­missible to enable particle generation at zero density. For ''PLOG'', ''amin'' > 0 is required. </div>

<div style="text-align:center;">[[Image:Image9.png|top]][[Image:Image10.png|top]]</div>

''Figure 1: The particle alpha value as a function of reference level (left) and atmos­pheric parameter (right) for different ‘levelmap’ and ‘atmsmap’ modes.''

== {{anchor|RefHeadingToc271829940}} Atmospheric flight model ==



=== Lift and drag theory ===

Drag is a force acting on the vessel in the direction of the freestream airflow. It is composed from several components:# The ''skin friction drag'' caused by the boundary layer surrounding the airfoil.
# The ''pressure drag'' caused by separation of flow from the surface.
# The ''wave drag'' at supersonic velocities.
# ''Induced drag'', caused by airflow around the wingtip (finite wing) from the lower to the upper surface.



The combination of components 1-3 is defined as ''profile drag'' or ''parasite drag''.

Lift is an upward force (perpendicular to the airflow) caused by the shape of the air­foil and its orientation to the airflow.

Drag ''D'' and lift ''L'' of an airfoil are expressed by the drag and lift coefficients ''c<sub>D''</sub> and ''c<sub>L''</sub>, with

<div style="text-align:center;"><math>{c}_{D}=\frac{D}{{q}_{\mathrm{\infty }}S},\phantom{\rule{2em}{0ex}}{c}_{L}=\frac{L}{{q}_{\mathrm{\infty }}S}</math></div>

where <math>{q}_{\mathrm{\infty }}=\raisebox{1ex}{$1$}\!\left/ \!\raisebox{-1ex}{$2$}\right.{\rho }_{\mathrm{\infty }}{V}_{\mathrm{\infty }}^{2}</math>is the freestream dynamic pressure, and ''S'' is the wing area. Gener­ally, ''c<sub>D''</sub> and ''c<sub>L''</sub>, will be functions of the angle of attack, the Mach number, and the Reynolds number. We now split ''c<sub>D''</sub> in the components of profile and induced drag. Induced drag is a result of lift and can be expressed as a function of ''c<sub>L''</sub>:

<div style="text-align:center;"><math>{c}_{D}={c}_{D,e}+\frac{{c}_{L}^{2}}{\pi \text{eA}}</math></div>

where ''e'' is a span efficiency factor, and ''A'' is the wing aspect ratio, defined as ''b<sup>2</sup>/S'' with wing span ''b''.

The profile component ''c<sub>D,e''</sub> will change with angle of attack. We assume that ''c<sub>D,e''</sub> can be expressed as the combination of a zero-lift component ''c<sub>D,0''</sub> and a component de­pending on ''c<sub>L''</sub>:

<div style="text-align:center;"><math>{c}_{D,e}={c}_{D\mathrm{,0}}+{\text{rc}}_{L}^{2}</math></div>

Here, ''r'' is a form constant which is usually determined empirically. We can now in­corporate the lift-dependent term of ''c<sub>D,e''</sub> into the factor ''e'', to give

<div style="text-align:center;"><math>{c}_{D}={c}_{D\mathrm{,0}}+\frac{{c}_{L}^{2}}{\text{πε}A}</math></div>

where <math>\epsilon =e/(\mathit{r\pi }\text{eA}+1)</math>is the ''Oswald efficiency factor''.

When implementing an airfoil in SpaceXpanse, the user must supply a function which cal­culates ''c<sub>L''</sub> and ''c<sub>D''</sub> for a given set of parameters (angle of attack, Mach number and Reynolds number). SpaceXpanse provides a helper function (oapiGetInducedDrag) to cal­culate the induced drag component with the above formula.

=== Lift and drag in transonic and supersonic flight ===

(to be completed)

=== Angular moments and vessel stability ===

(to be completed)

=== Angular drag ===

Similar to (linear) drag which produces a force acting against a vessel’s airspeed vec­tor, a rotating vessel will experience angular drag which acts against the angular ve­locity, thus slowing the rotation. SpaceXpanse uses the following formulae to calculate an­gular damping:

<div style="text-align:center;"><math>\begin{array}{c}{\text{dM}}_{x}=-{q}^{\text{'}}{S}_{y}{c}_{\alpha ,x}{\omega }_{x}\\ 
{\text{dM}}_{y}=-{q}^{\text{'}}{S}_{y}{c}_{\alpha ,y}{\omega }_{y}\\ 
{\text{dM}}_{z}=-{q}^{\text{'}}{S}_{y}{c}_{\alpha ,z}{\omega }_{z}\end{array}</math></div>

where <math>{q}^{\text{'}}=\raisebox{1ex}{$1$}\!\left/ \!\raisebox{-1ex}{$2$}\right.{\rho }_{\mathrm{\infty }}({V}_{\mathrm{\infty }}+{V}_{0}{)}^{2}</math>is a modified dynamic pressure which ensures that angular drag also occurs at low airspeeds (SpaceXpanse currently uses a fixed ''V''<sub>0</sub> = 30 m/s). ''S<sub>y''</sub> is the vessel’s cross section projected along the vertical (y) axis, used as a reference area. ''S<sub>y''</sub> is the ''y''-component of the vector passed to ''VESSEL::SetCrossSections()''. ''c<sub>,x''</sub>, ''c<sub>,y''</sub> and ''c<sub>,z''</sub> are the drag coefficients for rotations around the ''x'', ''y'', and ''z'' vessel axes as defined by ''VESSEL::SetRotDrag()''. ''<sub>x''</sub>, ''<sub>y''</sub> and ''<sub>z''</sub> are the angular velocities around the vessel axes, and ''dM<sub>x''</sub>, ''dM<sub>y''</sub> and ''dM<sub>z''</sub> are the changes in torque due to damping.

Angular drag is determined by the vessel shape. Developers can adjust the effect of angular damping in the atmosphere by adjusting the coefficients passed to ''VES­SEL::SetRotDrag()''. Higher coefficients make a vessel less responsive to control input, and reduce oscillations around equilibrium orientation.

=== API interface for airfoil definitions ===

To define the lift and drag characteristics for a spacecraft in the DLL module, use the ''VESSEL::CreateAirfoil'' method. An airfoil is defined as a cross section through a wing. In SpaceXpanse, we use the term airfoil for any components of the vessel which pro­duce lift and/or drag forces. Multiple airfoils can be defined for a single vessel (for example for the left and right wing, the body, the horizontal and vertical stabilizers in the tail, etc.). It is usually best to keep the number of airfoils low to keep the flight model predictable and to improve simulation performance.

SpaceXpanse distinguishes two different types of airfoil orientations: airfoils which create vertical lift (e.g. wings) and airfoils which create horizontal “lift”, e.g. vertical stabilis­ers. Even vessels without any wings or other aerodynamic surfaces should define at least one horizontal and one vertical airfoil to define their atmospheric drag behav­iour (even blunt objects such as reentry capsules which have no similarity to an air­craft produce drag ''and'' lift forces).

When calling the ''CreateAirfoil'' method, the user must provide* basic airfoil parameters (orientation, wing area, chord length and wing aspect ra­tio).
* the force attack point (i.e. the point on the vessel on which the lift and drag forces for this airfoil act). This influences the angular moments generated by the forces.
* a callback function which calculates the lift, drag and moment coefficients of the airfoil as a function of angle of attack '''', Mach number ''M'' and Reynolds number ''Re''.



The coefficients decide how much lift and drag is generated by the airfoil. The lift and drag forces (''L'' and ''D'') are obtained from the moments (''c<sub>L''</sub> and ''c<sub>D''</sub>) by

<div style="text-align:center;"><math>\begin{array}{c}L\left(\alpha ,M\text{,Re})={c}_{L}\right(\alpha ,M\text{,Re}){q}_{\mathrm{\infty }}S\\ 
D\left(\alpha ,M\text{,Re})={c}_{D}\right(\alpha ,M\text{,Re}){q}_{\mathrm{\infty }}S\end{array}</math></div>

with freestream dynamic pressure <math>{q}_{\mathrm{\infty }}=1/2{\mathit{\rho v}}^{2}</math>, and reference area ''S''. The function which calculates ''c<sub>L''</sub> and ''c<sub>D''</sub> must be able to handle arbitrary angles of attack (- to ) and very high Mach numbers which may occur during LEO insertion and atmos­pheric entry (orbital velocity for a low Earth orbit is equivalent to ''M'' > 20!)

The Reynolds number is a parameter dependent on atmospheric viscosity '''':

<div style="text-align:center;"><math>\text{Re}=\frac{\rho \text{vc}}{\mu }</math></div>

with freestream airspeed ''v'' and density ''''. In the current SpaceXpanse version, '''' is assumed constant ('''' = 1.689410<sup>-5</sup> kg m<sup>-1</sup> s<sup>-1</sup>). In future versions, '''' will depend on the atmos­pheric composition and temperature.

The direction of the lift force vector is defined in SpaceXpanse as

<div style="text-align:center;"><math>\begin{array}{c}{\hat{L}}_{\alpha }=(0,-{v}_{z},{v}_{y})/\sqrt{{v}_{y}^{2}+{v}_{z}^{2}}\\ 
{\hat{L}}_{\beta }=(-{v}_{z}\mathrm{,0},{v}_{x})/\sqrt{{v}_{x}^{2}+{v}_{z}^{2}}\end{array}</math></div>

for vertical and horizontal lift components, respectively, where (''v<sub>x</sub>,v<sub>y</sub>,v<sub>z''</sub>) is the freestream airflow vector in vessel coordinates. This means that <math>{\hat{L}}_{\alpha }</math>is rotated 90° counter-clockwise against the projection of the airflow vector into the yz-plane, and <math>{\hat{L}}_{\beta }</math>is rotated 90° counter-clockwise against the projection of the airflow vector into the xz-plane. Since '''' and '''' are defined as

<div style="text-align:center;"><math>\begin{array}{c}\alpha =\text{arctan}{v}_{y}/-{v}_{z}\\ 
\beta =\text{arctan}{v}_{x}/-{v}_{z}\end{array}</math></div>

we find the following relations between '''' or '''' and the direction of lift:


{| style="border-spacing:0;width:3.6424in;"
|-
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | ''''''''''
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | '''lift direction'''
| style="border-top:none;border-bottom:none;border-left:0.5pt solid #000000;border-right:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | ''''''''''
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | '''lift direction'''
|-
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 0°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | up (+y)
| style="border-top:none;border-bottom:none;border-left:0.5pt solid #000000;border-right:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 0°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | right (+x)
|-
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 90°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | forward (+z)
| style="border-top:none;border-bottom:none;border-left:0.5pt solid #000000;border-right:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 90°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | forward (+z)
|-
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 180°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | down (-y)
| style="border-top:none;border-bottom:none;border-left:0.5pt solid #000000;border-right:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 180°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | left (-x)
|-
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 270°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | backward (-z)
| style="border-top:none;border-bottom:none;border-left:0.5pt solid #000000;border-right:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | 270°
| style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | backward (-z)
|-
|}
This convention must be taken into account when defining the lift coefficient profile. For example, the ''c<sub>L''</sub> profile for a vertical stabiliser with symmetric airfoil should be positive for 0° ≤ '''' ≤ 90° and 180° ≤ '''' ≤ 270°, and negative for 90° ≤ '''' ≤ 180° and 270° ≤ '''' ≤ 360°. The lift profile in this case may therefore resemble sin 2''''. For asymmetric airfoils the lift profile will look more complicated (for example, the zero-lift angle will usually not be exactly 0°).

== {{anchor|Ref83676538}} {{anchor|RefHeadingToc271829941}} Defining an animation sequence ==

Animation sequences can be used to simulate movable parts of a vessel. Examples are the deployment of landing gear, cargo door operation, or animation of airfoils.

Animations are implemented in ''vessel modules'', using the ''VESSEL'' interface class.

SpaceXpanse allows 3 types of animation: rotation, translation and scaling. More complex can be built from these basic operations.

=== Semi-automatic animation ===

'''Mesh requirements:'''

Animations are performed by transforming mesh groups. Therefore, all parts of the mesh participating in an animation must be defined in separate groups. Multiple groups can participate in a single transformation.

'''Defining an animation sequence:'''

Create a member function for ''MyVessel'' to define animation sequences, and call it from the constructor, e.g.

MyVessel::MyVessel (OBJHANDLE hObj, int fmodel)

: VESSEL2 (hObj, fmodel)

{

DefineAnimations();

}

In the body of ''DefineAnimations()'', you now have to specify how the animation should be performed. Here is an example for a nose wheel animation:

void MyVessel::DefineAnimations()

{

static UINT groups[4] = {5,6,10,11}; // participating groups


static MGROUP_ROTATE nosewheel (

0, // mesh index

groups, 4, // group list and # groups

_V(0,-1.0,8.5), // rotation reference point _V(1,0,0), // rotation axis

(float)(0.5*PI) // angular rotation range

);


anim_gear = CreateAnimation (0.0);

AddAnimationComponent (anim_gear, 0, 1, &nosewheel);

}

You first need to determine which mesh groups take part in the animation. In this case, the nose wheel consists of the four groups 5, 6, 10 and 11, and these are listed in the “groups” array.

Next, you must define the parameters of the rotation. This is done by creating a ''MGROUP_ROTATE'' instance. Besides the mesh index and group indices, this also requires the rotation reference point (i.e. the point around which the mesh groups are rotated), the axis of rotation, and the rotation range.

A new animation is created by calling ''CreateAnimation''. The parameter passed to ''CreateAnimation'' defines the animation state in which the mesh groups are stored in the mesh. The return value identifies the animation.

Finally, the rotation of the nose wheel is added to the animation by calling ''AddAni­mationComponent''. The parameter are the animation identifier, the cutoff states of the component, and the transformation. The cutoff states define over which part of the animation the component transformation is applied. In this example, the cutoff states are 0 and 1, that is, the rotation of the nose wheel occurs over the full duration of the animation.

Now let’s consider a slightly more complicated example, where the animation con­sists of two components: (a) opening the wheel well cover, and (b) deploying the gear.

void MyVessel::DefineAnimations()

{

static UINT cover_groups[2] = {0,1};

static MGROUP_ROTATE cover (0, cover_groups, 2,

_V(-0.5,-1.5,7), _V(0,0,1), (float)(0.45*PI));


static UINT wheel_groups[4] = {5,6,10,11};

static MGROUP_ROTATE nosewheel (0, wheel_groups, 4,

_V(0,-1.0,8.5), _V(1,0,0), (float)(0.5*PI));


anim_gear = CreateAnimation (0.0);

AddAnimationComponent (anim_gear, 0, 0.5, &cover);

AddAnimationComponent (anim_gear, 0.4, 1, &nosewheel);

}

The rotations for the gear well cover and the landing gear are defined by two separate ''MGROUP_ROTATE'' variables. After creating the animation, both rotations are added as components. The cover is opened during the first part of the animation (between states 0 and 0.5) while the gear is deployed in the final part (between states 0.4 and 1). Note that there is a small overlap (between 0.4 and 0.5), which means that the gear begins to rotate before the cover is fully opened.

When the animation is played backward to retract the gear, the components are ro­tated in the inverse order: the gear is retracted first, then the cover is closed.

Animations can be arranged in a hierarchical order, so that a parent animation can transform mesh groups which are themselves animations. Consider for example the wheel on a landing gear which is spinning while the gear is being retracted. In this case, the gear animation is defined as a rotation around the gear hinge point, while the wheel animation is a rotation around the wheel axis. The wheel animation must be defined as a child of the gear animation, because the wheel is rotated together with the gear.

void MyVessel::DefineAnimations()

{

ANIMATIONCOMPONENT_HANDLE parent;


static UINT gear_groups[2] = {5,6};

static MGROUP_ROTATE gear (0, gear_groups, 2,

_V(0,-1.0,8.5), _V(1,0,0), (float)(0.45*PI));


static UINT wheel_groups[2] = {10,11};

wheel = new MGROUP_ROTATE (0, wheel_groups, 2,

_V(0,-1.0,6.5), _V(1,0,0), (float)(2*PI));


anim_gear = CreateAnimation (0.0);

parent = AddAnimationComponent (anim_gear, 0, 1, &gear);


anim_wheel = CreateAnimation (0.0);

AddAnimationComponent (anim_wheel, 0, 1, wheel, parent);

}

The gear and wheel rotations are defined by the ''MGROUP_ROTATE'' variables “gear” and “wheel”. Note that in this case “wheel” is not defined static, since reference point and axis will be modified by the parent. Therefore, “wheel” must be defined as a data member of the ''MyVessel'' class. Since “wheel” is allocated dynamically, don’t forget to de-allocate it with

MyVessel::~MyVessel()

{

...

delete wheel;

...

}

The return value of the ''AddAnimationComponent()'' call for the gear animation is a handle which identifies the transformation. We use this value for the optional parent parameter when defining the animation component for the wheel animation. This makes the wheel animation a child of the gear animation.

A complex example for hierarchical animations can be found in the RMS arm anima­tion of Space Shuttle Atlantis in ''SpaceXpansesdk\samples\Atlantis\Atlantis.cpp''.

Apart from rotations, mesh groups can also be transformed by translating and scal­ing. The corresponding ''MGROUP_TRANSFORM'' derivates are ''MGROUP_TRANSLATE'' and ''MGROUP_SCALE'':

MGROUP_TRANSLATE t1 (0, groups, 2, _V(0,10,5));

MGROUP_SCALE t2 (0, groups, 2, _V(5,0,2), _V(2,2,2));

In both cases, the first three parameters are the same as for ''MGROUP_ROTATE'' (mesh, index, group list and number of groups). For ''MGROUP_TRANSLATE'', the last parameter defines the translation vector. For ''MGROUP_SCALE'', the last two pa­rameters define the scale origin, and the scale factors in the three axes.

'''Performing the animation:'''

To animate the nose wheel now, we need to manipulate the animation sequence state by calling ''SetAnimation()'' with a value between 0 (fully retracted) and 1 (fully de­ployed). This is typically done in the ''Timestep()'' member function, e.g.

void MyVessel::Timestep (double simt)

{

if (gear_status == CLOSING || gear_status == OPENING) {

double da = oapiGetSimStep() * gear_speed;

if (gear_status == CLOSING) {

if (gear_proc > 0.0)

gear_proc = max (0.0, gear_proc-da);

else

gear_status = CLOSED;

} else { // door opening

if (gear_proc < 1.0)

gear_proc = min (1.0, gear_proc+da);

else

gear_status = OPEN;

}

SetAnimation (anim_gear, gear_proc);

}

}

Here, gear_status is a flag defining the current operation mode (''CLOSING'', ''OPEN­ING'', ''CLOSED'', ''OPEN''). This will typically be set by user interaction, e.g. by pressing a keyboard button. If the animation is in progress (''OPENING'' or ''CLOSING''), we de­termine the rotation step (da) as a function of the current frame interval (''oapiGet­TimeStep''). The value of ''gear_speed'' defines how fast the gear is deployed.

Next, we update the deployment state (''gear_proc''), and check whether the sequence is complete (0 if closing, or 1 if opening). Finally, ''SetAnimation'' is called to perform the animation.

The SpaceCruiser sample module (''SpaceXpansesdk\samples\SpaceCruiser'') contains a com­plete example for an animation implementation.

=== Manual animation ===

As an alternative to the (semi-)automatic animation concept described in the previ­ous section, SpaceXpanse also allows manual animation. This can be more versatile, but requires more effort from the module developer, because the complete animation se­quence must be implemented explicitly.

A manual animation sequence is created by the functions ''VES­SEL::RegisterAnimation()'' and ''VESSEL::UnregisterAnimation()''. A call to ''Register­Animation'' causes SpaceXpanse to call the module’s ''ovcAnimate'' callback function at each frame, provided the vessel’s visual exists. ''UnregisterAnimation'' cancels the request.

Note that ''RegisterAnimation''/''UnregisterAnimation'' pairs can be nested. Each call to ''RegisterAnimation'' increments a reference counter, each call to ''UnregisterAnimation'' decrements the counter. SpaceXpanse will call ''ovcAnimate'' as long as the counter is > 0.

It is up to the module to implement its animations in the body of ''ovcAnimate''. Typi­cally this will involve calls to ''MeshgroupTransform()'', to rotate, translate or scale mesh groups as a function of the last simulation time step. Note that ''ovcAnimate'' is called only once per frame, even if more than one ''RegisterAnimation'' request has been logged. The module must therefore decide which animations need to be processed in ''ovcAnimate''.

''UnregisterAnimation'' should never be called from inside ''ovcAnimate'', since ''ovcAni­mate'' is only called if the visual exists. This could cause the unregister request to be lost. It is better to test for animation termination in ''ovcTimestep''.

== {{anchor|Ref271751093}} {{anchor|RefHeadingToc271829942}} Designing 2D-instrument panels ==

Instrument panels are a good way to give an individual feel to a spacecraft class and allow the user to monitor flight parameters and control specific aspects of the vessel via the mouse, without the need to remember a large number of keyboard commands.

There are two ways to define a cockpit interior: you can build one (or several) flat two-dimen­sional panels as bitmaps which are overlayed on top of the three-dimen­sional scenery of the simulation window (denoted as ''panels'' below), or you can con­struct a full three-dimensional mesh representation of the cockpit (denoted as ''virtual cockpit'', or ''VC'' below). A vessel can implement both 2-D panels and virtual cockpits. The user can switch between them (and the ge­neric cockpit view comprising two MFD displays and HUD) by pressing F8.

In this section we will discuss the steps required to define 2-D panels in the vessel mod­ule. Section 1.13will deal with virtual cockpits.

=== The panel request callback function ===

Whenever the vessel switches to a new 2-D panel cockpit view (either from an outside view or another cockpit view), it calls the ''clbkLoadPanel2D'' callback function. This is the point where we need to define the panel geometry and functions. For now, we are going to implement only a single main panel:

bool MyVessel::clbkLoadPanel2D (int id, PANELHANDLE hPanel,

DWORD viewW, DWORD viewH)

{

switch (id) {

case 0: 

DefineMainPanel (hPanel);

ScalePanel (hPanel, viewW, viewH);

return true;

default:

return false;

}

}

Note that ''clbkLoadPanel2D'' has been introduced in the ''VESSEL3'' interface, so your vessel class must be derived from ''VESSEL3'' to make use of it. ''clbkLoadPanel2D'' is the equivalent of ''clbkLoadPanel'' for the old-style 2-D panel interface. If your vessel defines ''clbkLoadPanel2D'', it should ''not'' also define ''clbkLoadPanel''.

The ''id'' parameter defines the panel (the main panel has always ''id'' 0, but additional neighbour panels can be defined as well). The ''hPanel'' object is a handle that is re­quired by various functions during the definition of the panel. The ''viewW'' and ''viewH'' parameters define the width and height of the viewport in pixels, which can be useful for scaling purposes.

Now we need to implement the ''DefineMainPanel'' function which defines the panel mesh, textures and active areas.

=== The panel mesh ===

2-D instrument panels are defined as ''2-D meshes''. SpaceXpanse uses the same mesh format for 2-D meshes as it does for 3-D meshes (used e.g. to describe vessel and virtual cock­pit geometries), with the exception that the vertex z-coordinates for 2-D meshes are ignored and should be set to 0.

The mesh coordinate system to which the mesh vertex coordinates refer can be freely chosen by the developer. A convenient convention is to set the bottom left corner of the mesh to coordinates (0,0), and the top right corner to coordinates (''px'',''py''), where ''px'' and ''py'' are the width and height of the panel background texture in pixels. With this convention, mesh coordinates correspond to the pixel positions of the back­ground texture.

As a first example, let’s start with a simple rectangular panel, which can be defined with 4 vertices and 2 triangles. If we plan for a panel texture of dimension 1280x400, then the mesh would look like this:

<div style="margin-left:0in;margin-right:0in;">Vertex coordinate list(0,0,0), (0,400,0), (1280,400,0), (1280,0,0)</div>

<div style="margin-left:0in;margin-right:0in;">Triangle index list(0,2,1), (2,0,3)</div>

In principle it is possible to put this mesh definition into a standard SpaceXpanse mesh file, and read it when required with ''oapiLoadMesh''. However, this mesh is so simple that it is more efficient to define it directly in the vessel code. Defining the 2-D panel mesh in the code will later also have the advantage that we are better able to control an­imations and moving parts which require direct access to the vertex lists. The main panel mesh definition could look like this:

void MyVessel::DefineMainPanel (PANELHANDLE hPanel)

{

static DWORD panelW = 1280;

static DWORD panelH = 400;

float fpanelW = (float)panelW;

float fpanelH = (float)panelH;

static NTVERTEX VTX[4] = {

{ 0, 0,0, 0,0,0, 0,0},

{ 0,fpanelH,0, 0,0,0, 0,0},

{fpanelW,fpanelH,0, 0,0,0, 0,0},

{fpanelW, 0,0, 0,0,0, 0,0}

};

static WORD IDX[6] = {

0,2,1,

2,0,3

};


if (hPanelMesh) oapiDeleteMesh (hPanelMesh);

hPanelMesh = oapiCreateMesh (0,0);

MESHGROUP grp = {VTX, IDX, 4, 6, 0, 0, 0, 0, 0};

oapiAddMeshGroup (hPanelMesh, &grp);

SetPanelBackground (hPanel, 0, 0, hPanelMesh, panelW, panelH, 0,

PANEL_ATTACH_BOTTOM | PANEL_MOVEOUT_BOTTOM);

}

Here, ''hPanelMesh'' is assumed to be a ''MESHHANDLE'' object defined as a member of ''MyVessel''. The call to ''oapiCreateMesh'' creates an empty mesh, to which the group for the main panel background is added by ''oapiMeshGroup''.

Since the ''hPanelMesh'' object may be shared with other cockpit panel views, we need to check if it is allocated already, and delete it before defining the new one, using the ''oapiDeleteMesh'' function. For this to work, it must be initialised it to ''NULL'' in the constructor:

<div style="color:#808080;">MyVessel::MyVessel(OBJHANDLE hObj, int fmodel)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

hPanelMesh = NULL;

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

To avoid memory leaks, the destructor should delete the mesh if required:

<span style="color:#808080;">MyVessel::~MyVessel ()</span>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

if (hPanelMesh) oapiDeleteMesh (hPanelMesh);

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

The ''SetPanelBackground'' call in our ''DefineMainPanel'' function registers the panel mesh with SpaceXpanse. Its parameters are:* <div style="margin-left:0.248in;margin-right:0in;">The panel handle, as provided by ''clbkLoadPanel2D''</div>
* <div style="margin-left:0.248in;margin-right:0in;">A list of textures, and the number of textures in the list (set to 0 for now – we’ll come back to those later)</div>
* <div style="margin-left:0.248in;margin-right:0in;">The panel mesh handle</div>
* <div style="margin-left:0.248in;margin-right:0in;">The width and height of the panel in mesh units</div>
* <div style="margin-left:0.248in;margin-right:0in;">The panel base line</div>
* <div style="margin-left:0.248in;margin-right:0in;">The viewport attachment and scroll flags</div>



=== Scaling the panel ===

Now we have to think about scaling the panel to the viewport. This will be done in the ''ScalePanel'' method that has already been called in ''clbkLoadPanel2D''.

By default, we want to scale the panel so that it fills the width of the viewport, inde­pendent of its actual size. This can be done painlessly by using the ''VES­SEL3::SetPanelScaling'' method. This is a big improvement over the old-style panel definitions, which only provided an awkward global scaling option. In addition, we can also define a zoom option that magnifies the panel. This will only display a part of the panel, but other parts can be scrolled in. This is particularly useful for small view­port sizes, where scaling the panel to fit would make it too small to use. The user can switch between standard and magnified scaling with the mouse wheel.

The scaling parameters passed to ''SetPanelScaling'' are magnification factors that de­scribe how many viewport pixels should be covered by one mesh unit. The imple­mentation of ''ScalePanel'' could therefore look like this:

void MyVessel::ScalePanel (PANELHANDLE hPanel, DWORD viewW, DWORD viewH)

{

double defscale = (double)viewW/1280.0;

double magscale = max (defscale, 1.0);

SetPanelScaling (hPanel, defscale, magscale);

}

The ''defscale'' factor makes sure that the panel (defined as size 1280) stretches over the full viewport width (viewW). The ''magscale'' factor magnifies the panel such that 1 mesh unit covers one screen pixel if the viewport width is smaller than the panel width. This is a sensible convention, but of course you are free to implement different scaling strategies for your panels.

=== Adding a panel background texture ===

We now want to draw a texture over the bare panel mesh. The texture serves the same function as the bitmap in the old-style panel definitions, but it must be stored in DDS format, rather than BMP format. You may have to experiment with the com­pression format, but usually DXT1 is best if no or only binary transparency is re­quired, or DXT5 if continuous transparency is required.

Another important restriction is the fact that textures must have sizes that are multi­ples of 2. So for our 1280x400 texture we will have to create a 2048x512 pixel texture. For now this is a lot of waste, but we can use the same texture to add additional pan­els and active elements later on. Sometimes you may also be able to reduce the re­quired texture size by clever mesh design and re-using the same texture elements multiple times (e.g. defining the right half of the panel as a mirror of the left).

The panel texture is a global resource (it is shared by all vessels of the MyVessel class, so we can make it static and load it during module initialisation:

<div style="color:#808080;">// vessel class interface</div>

<div style="color:#808080;">class MyVessel: public VESSEL3</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">public:</div>

<div style="color:#808080;">...</div>

static SURFHANDLE panel2dtex;

<div style="color:#808080;">...</div>

<div style="color:#808080;">};</div>


<div style="color:#808080;">// public member initialisation</div>

SURFHANDLE MyVessel::panel2dtex = NULL;


<div style="color:#808080;">// module initialisation</div>

<div style="color:#808080;">DLLCLBK void InitModule (HINSTANCE hModule)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

MyVessel::panel2dtex = oapiLoadTexture (“MyVessel\\panel2d.dds”);

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>


<div style="color:#808080;">// module cleanup</div>

<div style="color:#808080;">DLLCLBK void ExitModule (HINSTANCE hModule)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

oapiDestroySurface (MyVessel::panel2dtex);

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

where the panel texture is assumed to be located in file ''Tex­tures\MyVes­sel\panel2d.dds''.

We can now modify the ''DefineMainPanel'' method to make use of the background texture:

<div style="color:#808080;">void MyVessel::DefineMainPanel (PANELHANDLE hPanel)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">static DWORD panelW = 1280;</div>

<div style="color:#808080;">static DWORD panelH = 400;</div>

<div style="color:#808080;">float fpanelW = (float)panelW;</div>

<div style="color:#808080;">float fpanelH = (float)panelH;</div>

static DWORD texW <nowiki>= 2048;</nowiki>

static DWORD texH <nowiki>= </nowiki>512;

float ftexW <nowiki>= (float)texW;</nowiki>

float ftexH <nowiki>= (float)texH;</nowiki>

<div style="color:#808080;">static NTVERTEX VTX[4] = {</div>

<span style="color:#808080;">{ 0, 0,0, 0,0,0, </span>0.0f,1.0f–fpanelH/ftexH<span style="color:#808080;">},</span>

<span style="color:#808080;">{ 0,fpanelH,0, 0,0,0, </span>0.0f,1.0f<span style="color:#808080;"> },</span>

<span style="color:#808080;">{fpanelW,fpanelH,0, 0,0,0, </span>fpanelW/ftexW,1.0f<span style="color:#808080;"> },</span>

<span style="color:#808080;">{fpanelW, 0,0, 0,0,0, </span>fpanelW/ftexW,1.0f-fpanelH/ftexH<span style="color:#808080;">}</span>

<div style="color:#808080;">};</div>

<div style="color:#808080;">static WORD IDX[6] = {</div>

<div style="color:#808080;">0,2,1,</div>

<div style="color:#808080;">2,0,3</div>

<div style="color:#808080;">};</div>


<div style="color:#808080;">if (hPanelMesh) oapiDeleteMesh (hPanelMesh);</div>

<div style="color:#808080;">hPanelMesh = oapiCreateMesh (0,0);</div>

<div style="color:#808080;">MESHGROUP grp = {VTX, IDX, 4, 6, 0, 0, 0, 0, 0};</div>

<div style="color:#808080;">oapiAddMeshGroup (hPanelMesh, &grp);</div>

<span style="color:#808080;">SetPanelBackground (hPanel, </span>&panel2dtex, 1,<span style="color:#808080;"> hPanelMesh, panelW, panelH, 0,</span>

<div style="color:#808080;">PANEL_ATTACH_BOTTOM | PANEL_MOVEOUT_BOTTOM);</div>

<div style="color:#808080;">}</div>

The texture coordinates for the mesh vertices have now been defined (where I am as­suming that the main panel image is located in the lower left corner of the texture. The call to ''SetPanelBackground'' contains a pointer to the texture handle, and the number of textures (1). If your panel mesh references more than one texture, put them in a list, pass the list as the second parameter of ''SetPanelBackground'', and the number of textures in the list as the third parameter.

At this point, you can compile your vessel code and run it in SpaceXpanse. It isn’t very ex­citing yet (a static panel background texture covering the lower half of the screen), but it is the basis for the next steps. You should be able to scroll the panel up and down with the cursor keys.

== {{anchor|RefHeadingToc271829943}} Designing instrument panels (legacy style) ==

This section describes the design for a legacy-style 2-D instrument panel. This method is still supported by SpaceXpanse, but its use is discouraged, because it does not work well with newer 3-D rendering engines and external graphics clients. Vessel ad­don design­ers should switch to the new 2-D panel method described in Section 1.11.

=== Defining a panel ===

You will first need to create a bitmap which represents the 2-D instrument panel. You can use any paint tool capable of generating Windows BMP files. The panel can be saved in 8-bit or 24-bit mode, but 8-bit mode is strongly recommended to reduce the size of the resulting vessel module, and improve simulation performance.

[[Image:Image11.png|top]]

''Figure 2: The SC main panel bitmap.''

Some thought should be given to the size of the panel bitmap. Remember that users will run SpaceXpanse at different screen resolutions and window sizes. If the bitmap is made very large, a lot of panning will be required to bring different parts of the panel into view at low resolutions. If the bitmap is very small, it will cover only a small area of the screen at high resolutions. It is probably best to design panels for medium screen resolutions (between 1024x768 and 1280x960 pixels). Users with very low or very high screen resolutions will be able to adjust the panel size by using SpaceXpanse's panel rescaling option.

You should also consider whether the panel is to cover the whole screen, or only part of it. The main panel should usually obstruct only part of the 3-D scenery, but side panels could take up the whole simulation window.

The main panel should typically also provide space for MFDs (multifunctional dis­plays), which are the primary method to provide flight data to the pilot. Most com­mon is a layout with two MFDs, but fewer or more can be defined as well. The size of the MFD displays should be chosen so that they are easily readable over a 'typical' range of screen resolutions.

You can define more than one panel for a vessel. For example, you may define a main panel which is visible in the lower half of the screen when the pilot looks forward, an overhead panel, side panels, etc. The user can switch between the different panels with Ctrl+cursor keys. We will discuss later how to define the connectivity between panels. To start with, let's look at the definition of a single main panel.

Once you have created the panel BMP file, you should add it as a bitmap resource to your vessel module project. Now you are ready to write the code to support the panel. To do so, you need to overload the ''clbkLoadPanel'' method of the ''VESSEL2'' class:

bool MyVessel::clbkLoadPanel (int id)

{

...

}

Here we assume that ''MyVessel'' is a class derived from ''VESSEL2'' (see Section 1.2on how to create vessel instances). ''id'' is a panel identifier which SpaceXpanse will provide to let your function know which panel is required. If only a single main panel is defined, ''id'' will always be 0. If you define more than one panel, you should examine this pa­rameter to decide which panel to load.

SpaceXpanse will call your ''clbkLoadPanel'' method whenever it needs to load an instrument panel. This happens if* the user switches to instrument panel view from another view mode by pressing F8.
* the user switches between panels with Ctrl+cursor keys.
* the user switches from an external view to a cockpit view.
* the user switches to a different spacecraft with F3.



In the body of ''clbkLoadPanel'', we need to load the panel bitmap and pass it to SpaceXpanse via the ''oapiRegisterPanelBack­ground'' function:

bool MyVessel::clbkLoadPanel (int id)

{

HBITMAP hBmp = LoadBitmap (hDLL, MAKEINTRESOURCE(IDB_PANEL));

oapiRegisterPanelBackground (hBmp);

return true;

}

Here, ''hDLL'' is a module instance handle passed to the ''InitModule'' callback function of your module, and ''IDB_PANEL'' is assumed to be the numerical resource identifier of the panel bitmap. The return value of ''clbkLoadPanel'' should normally be ''true''. ''false'' signifies an error, e.g. failure to load the panel bitmap.

''oapiRegisterPanelBackground'' has an additional optional parameter which defines how the panel is connected to the edges of the simulation window, and how it can be scrolled across the screen with the cursor keys. A common choice for a main window is to connect it to the lower edge of the window, and allow it to be scrolled downward. This can be accomplished as follows:

oapiRegisterPanelBackground (hBmp,

PANEL_ATTACH_BOTTOM|PANEL_MOVEOUT_BOTTOM);

(This is in fact the default setting, so you only need to provide this parameter if you need to define a different behaviour.) For a full list of supported attachment and scroll parameters, see the ''oapiRegisterPanelBackground'' description in the Reference Manual.

''oapiRegisterPanelBackground'' has a further optional parameter to define a transpar­ent col­our. Any part of the bitmap containing that colour will be transparent in the render window. This allows to implement irregular panel shapes such as windows which provide a view of the 3-D scene though the panel.

The transparent colour is given in 0xRRGGBB format. Note that if SpaceXpanse is run in 16-bit mode, not all colours can be represented. For that reason, it is recommended to use either black (0x000000) or white (0xFFFFFF) as the transparent colour which are always available in 16-bit mode, to avoid problems. In any case, you should al­ways check that your panel ap­pears correctly in both 16 and 32 bit modes before pub­lishing your addon.

So the final version of our main panel loading call looks like this, where we allow the panel to be scrolled out at the bottom, and use white as the transparent colour:

oapiRegisterPanelBackground (hBmp,

PANEL_ATTACH_BOTTOM|PANEL_MOVEOUT_BOTTOM, 0xFFFFFF);

At this point, you can try to compile your module and test the panel in SpaceXpanse. You should be able to make the panel visible by pressing F8 when you are in the cockpit of an instance of your vessel class, and scroll it up and down with the cursor keys.

=== Defining active panel areas ===

Now we can start to do something interesting with our new panel. We need to ''acti­vate'' areas of the panel. Active areas can do two things:* They can be repainted from within the code, for example to dynamically update an instrument display, and/or
* they can register mouse button events to allow the user to interact with the panel.



A panel area is activated with the ''oapiRegisterPanelArea'' function. This must be called in your vessel's ''clbkLoadPanel'' method, after the panel has been loaded with ''oapiRegisterPanel­Background''. Let's define an area that contains a button which the user can press:

oapiRegisterPanelArea (AID_BUTTON, _R(10,10,30,20),

PANEL_REDRAW_MOUSE, PANEL_MOUSE_LBDOWN, PANEL_MAP_BACKGROUND);

The first parameter, ''AID_BUTTON'', is a value that uniquely identifies the area across all pan­els. The next parameter defines a rectangular area in the panel given by the left, top, right and bottom edges (measured from the top left corner of the panel bit­map).

The next parameter, ''PANEL_REDRAW_MOUSE'', specifies that the area must be re­drawn whenever a mouse event occurs inside the area. Other areas may need to be redrawn at each frame, by explicitly requesting a redraw, or not at all.

''PANEL_MOUSE_LBDOWN'' requests a notification whenever the user presses the left mouse button inside the area. You can also request mouse button releases, or con­tinuous notifica­tions as long as a button is pressed. A panel area defined with ''PANEL_MOUSE_IGNORE ''will never generate any mouse events.

''PANEL_MAP_BACKGROUND'' requests the area background (i.e. the portion of the panel bitmap under the area) to be passed to the redraw function. Instead, you could request the current status of the area, or an un-initialised bitmap to be passed to the redraw function. See the documentation to ''oapiRegisterPanelArea'' in the Reference Manual for more details.

You can define more panel areas to turn your panel into a useful interface, but avoid overlap­ping areas.

Next, we need to implement the callback functions SpaceXpanse will call to allow the mod­ule to re­spond to redraw and mouse events generated by the active areas.

=== The mouse event handler ===

To intercept mouse events generated by a panel you must overload the ''clbkPanel­MouseEvent'' method of the ''VESSEL2'' class:

bool MyVessel::clbkPanelMouseEvent (int id, int event, int mx, int my)

{

...

}

where ''id'' is the identifier of the panel area for which the event was generated (e.g. ''AID_BUTTON'' in our example), ''event'' specifies the mouse event type, and ''mx,my ''are the panel coordinates at which the event occurred.

'''Important''': A button-up event is always generated for the instrument which pro­duced the pre­ceding button-down event, even if the mouse has been dragged out of the panel area in the mean time.

The following mouse events are available:

''PANEL_MOUSE_LBDOWN''Left mouse button pressed down.

''PANEL_MOUSE_RBDOWN''Right mouse button pressed down.

''PANEL_MOUSE_LBUP''Left mouse button released.

''PANEL_MOUSE_RBUP''Right mouse button released.

''PANEL_MOUSE_LBPRESSED''Left mouse button down

''PANEL_MOUSE_RBPRESSED''Right mouse button down.

The ''PANEL_MOUSE_LBPRESSED'' and ''PANEL_MOUSE_RBPRESSED'' events are sent continuously while the buttons are held down. This allows the implementation of mouse-dragging event, for example to move sliders with the mouse.

Inside ''clbkPanelMouseEvent'', your code must check the area id and perform the ap­propriate actions:

bool MyVessel::clbkPanelMouseEvent (int id, int event, int mx, int my)

{

switch (id) {

case AID_BUTTON:

DoProcessButtonPress (...);

return true;

case ... // place response to other areas here

}

return false;

}

Here, ''DoProcesButtonPress'' is assumed to be a locally defined method which per­forms the required action.

The return value is currently only used for areas which use the ''PANEL_REDRAW_MOUSE'' flag. In this case, returning ''true'' will trigger a redraw event, while returning ''false'' will not. For efficiency, return ''true'' only if the area needs to be redrawn as a consequence of the mouse event.

The ''mx'' and ''my'' parameters define the area coordinates (0,0 is the top left corner of the area) at which the mouse event occurred. This is sometimes useful to fine-tune the response. For example, let's assume that the button defined in the example is ac­tually a switch which can be flipped left or right. Then we could do this:

...

case AID_BUTTON:

if (mx < 10)

DoProcessFlipLeft (...);

else

DoProcessFlipRight (...);

return true;

...

=== The redraw event handler ===

To provide a visual cue of the button press, we may want to redraw the area (e.g. to simulate a control lamp lighting up). Other areas representing gauges and displays may need to be re­drawn continuously without any mouse events. To respond to re­draw requests, we need to overload the ''clbkPanelRedrawEvent'' method of the ''VES­SEL2'' class:

bool MyVessel::clbkPanelRedrawEvent (int id, int event, SURFHANDLE surf)

{

...

}

As with the mouse event handler, your implementation of ''clbkPanelRedrawEvent'' should ex­amine the area ''id'' (and the redraw ''event'', if required), and redraw the corre­sponding area as required.

''surf'' is a handle to the paint surface for the area in which all repainting takes place. The con­tents of the surface passed to the callback function depend on the parameters specified dur­ing the definition of the area:

<div style="margin-left:2.461in;margin-right:0in;">''PANEL_MAP_NONE''surf is undefined</div>

<div style="margin-left:2.461in;margin-right:0in;">''PANEL_MAP_BACKGROUND''surf contains area background</div>

<div style="margin-left:2.461in;margin-right:0in;">''PANEL_MAP_CURRENT''surf contains current area contents</div>

<div style="margin-left:2.461in;margin-right:0in;">''PANEL_MAP_BGONREQUEST''surf is undefined, but area background can be ob­tained on request</div>

''PANEL_MAP_NONE'' is the most efficient option if the whole area needs to be re­drawn at each redraw event. ''PANEL_MAP_BACKGROUND'' is least efficient, because it involves the most internal surface copy processes. If you need the background bit­map, but your area doesn't need to be redrawn for each redraw request generated (for example, if you have de­fined a gauge, to be redrawn at each simulation frame, but often the contents don't change between subsequent frames), it is more efficient to use the ''PANEL_MAP_BGONREQUEST'' flag, and obtaining the background bitmap explicitly with a call to ''oapiBltPanelAreaBack­ground'' whenever the area actually needs to be redrawn (see documentation to ''oapiBltPanel­AreaBackground'' in the Ref­erence Manual for more details).

Our redraw function might look like this:

<div style="color:#808080;">bool MyVessel::clbkPanelRedrawEvent (int id, int event, SURFHANDLE surf)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (id) {</div>

case AID_BUTTON:

if (button_pressed)

oapiBlt (surf, buttonSurf, 0, 0, 0, 0, 20, 10);

else

oapiBlt (surf, buttonSurf, 0, 0, 0, 10, 20, 10);

return true;

<div style="color:#808080;">case ... // imprement redraw methods for other areas</div>

<div style="color:#808080;">}</div>

<div style="color:#808080;">return false;</div>

<div style="color:#808080;">}</div>

Here, ''buttonSurf'' is assumed to be the surface handle to a bitmap which contains im­ages of the button for both the pressed and the released state. (You can store this bitmap as a mod­ule resource and obtain a surface handle to it with the ''oapiCre­ateSurface'' method.) ''oapiBlt'' copies the relevant part of the bitmap into the area's surface (the ''button_pressed'' flag could for example have been set in the mouse event handler).

When more complex redrawing is required, you can obtain a device context handle to the surface with ''oapiGetDC'' and then use standard Windows GDI methods to paint in the surface. (see Windows API documentation). Don't forget to release the device context with ''oapiRe­leaseDC'' at the end.

The return value of ''clbkPanelRedrawEvent'' signals to SpaceXpanse if the contents of the area have been redrawn. Return ''true'' only if you did modify the surface, ''false'' other­wise.

=== {{anchor|Ref83680397}} Defining panel MFDs ===

MFD (multifunctional displays) are probably the most important components of your panel. They are defined differently to other panel areas, because some of the redraw events are processed directly by SpaceXpanse.

MFDs consist of a square display area (representing a colour CRT or LCD display) and rows of control buttons to the left and right. The number of buttons can be de­fined individually.

You reserve a panel area for an MFD with the ''oapiRegisterMFD'' method during set­ting up the panel in the overloaded ''clbkLoadPanel'' callback function:

<div style="color:#808080;">bool MyVessel::clbkLoadPanel (int id)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">oapiRegisterPanelBackground (...);</div>

<div style="color:#808080;">...</div>

MFDSPEC mfds_left <nowiki>= {{100, 10, 200, 110}, 6, 6, 10, 20};</nowiki>

oapiRegisterMFD (MFD_LEFT, mfds_left);

<div style="color:#808080;">...</div>

<div style="color:#808080;">return true;</div>

<div style="color:#808080;">}</div>

The first parameter of ''oapiRegisterMFD'' identifies the MFD (left, right, or a user-de­fined MFD). The left and right MFDs can be controlled with keyboard commands, while user-de­fined MFDs can only be controlled with the mouse. Therefore you should always first define the left and right MFDs, and use user-defined ones only if more than two MFDs are to be de­fined in the panel.

The second parameter is a structure which defines the layout of the MFD. It contains:* the rectangular area (left, top, right and bottom edge) of the panel area to contain the MFD display,
* the number of buttons along the left and right edges,
* the y-offset of the upper edge of the topmost button from the top edge of the dis­play,
* the y-distance between the top edges of the buttons.



The button rows must be implemented as separate areas. Note that a single area is used for the left row of buttons, and another one for the right row. In addition, a bottom row of 3 buttons can be defined to perform MFD on/off, display of button commands, and display of mode contents:

<div style="color:#808080;">bool MyVessel::clbkLoadPanel (int id)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">oapiRegisterPanelBackground (...);</div>

<div style="color:#808080;">...</div>

<div style="color:#808080;">MFDSPEC mfds_left <nowiki>= {{100, 10, 200, 110}, 6, 6, 10, 20};</nowiki></div>

<div style="color:#808080;">oapiRegisterMFD (MFD_LEFT, mfds_left);</div>

oapiRegisterPanelArea (AID_LBUTTONS, _R(80,20,100,100), PANEL_REDRAW_USER,

PANEL_MOUSE_LBDOWN|PANEL_MOUSE_LBPRESSED, PANEL_MAP_BACKGROUND);

oapiRegisterPanelArea (AID_RBUTTONS,_R(200,20,220,100), PANEL_REDRAW_USER,

PANEL_MOUSE_LBDOWN|PANEL_MOUSE_LBPRESSED, PANEL_MAP_BACKGROUND);

oapiRegisterPanelArea (AID_BBUTTONS,_R(100,110,200,130), 

PANEL_REDRAW_NEVER, PANEL_MOUSE_LBDOWN);

<div style="color:#808080;">...</div>

<div style="color:#808080;">return true;</div>

<div style="color:#808080;">}</div>

The button areas have been defined with the ''PANEL_MOUSE_LBPRESSED'' flag in addition to ''PANEL_MOUSE_LBDOWN'', so that continued mouse presses can be re­corded when required.

Mouse button events now need to be processed in the mouse event handler:

<div style="color:#808080;">bool MyVessel::clbkPanelMouseEvent (int id, int event, int mx, int my)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (id) {</div>

case AID_LBUTTONS:

case AID_RBUTTONS:

if (my%20 < 15) {

int bt = my/20 + (id == AID_LBUTTONS ? 0 : 6);

oapiProcessMFDButton (MFD_LEFT, bt, event);

return true;

}

break;

<div style="color:#808080;">case ...</div>

<div style="color:#808080;">}</div>

<div style="color:#808080;">return false;</div>

<div style="color:#808080;">}</div>

This code fragment processes all the buttons in the left and right button columns si­multaneously. It first checks if the mouse event occurred over a button (''my%20 < 15''), assuming that each button is 15 pixels high, and buttons are spaced in 20 pixel intervals. It then checks if the event occurred in the left or right button column, and determines which of the buttons was pressed (''bt''). Finally, the ''oapiProcessMFDBut­ton'' function is called with the appropriate parameters, to allow SpaceXpanse to respond to the MFD request.

The bottom row of buttons is processed similarly:

...

case AID_BBUTTONS:

if (mx < 20)

oapiToggleMFD_on (MFD_LEFT);

else if (mx >= 30 && mx < 50)

oapiSendMFDKey (MFD_LEFT, OAPI_KEY_F1);

else if (mx > 60)

oapiSendMFDKey (MFD_LEFT, OAPI_KEY_GRAVE);

return true;

...

where ''oapiToggleMFD_on'' switches the MFD on/off, and the ''oapiSendMFDKey'' commands trigger the default actions of displaying the key commands and the MFD mode list.

Of course, the values of the various mouse x and y values in an actual implementation will depend on the geometry of the individual MFD layout. You could even define each single button as a separate area, but this will generally result in less efficient code.

Finally, the MFD buttons need to respond to redraw events, to reflect the change of button la­bels (for example, when the MFD mode changes). Note that the MFD dis­play area itself is auto­matically updated by SpaceXpanse and therefore doesn't need to im­plement a redraw response.

<div style="color:#808080;">bool MyVessel::clbkPanelRedrawEvent (int id, int event, SURFHANDLE surf)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (id) {</div>

case AID_LBUTTONS:

case AID_RBUTTONS:

side = (id == AID_LBUTTONS ? 0:1);

hDC = oapiGetDC (surf);

for (int bt = 0; bt < 6; bt++) {

if (label = oapiMFDButtonLabel (MFD_LEFT, bt+side*6))

TextOut (hDC, 5, 2+20*bt, label, strlen(label));

else break;

}

oapiReleaseDC (surf, hDC);

return true;

<div style="color:#808080;">case ...</div>

<div style="color:#808080;">}</div>

<div style="color:#808080;">return false;</div>

<div style="color:#808080;">}</div>

This uses the ''oapiMFDButtonLabel'' function to retrieve the label text for each of the buttons (button labels consist of 1 to 3 characters). The redraw function can be cus­tomised to reflect the style in which the button labels are dis­played (for example by changing the font size or colour).

Note that the bottom row of buttons does not necessarily need to implement a redraw method, because their labels never change.

=== Multiple panels ===

To implement multiple panels for a vessel, the ''clbkLoadPanel'' method must load dif­ferent panels depending on the provided panel ''id'', and each of the panels must define its connec­tivity to neighbouring panels via the ''oapiSetPanelNeighbours'' function.

Example: If your vessel supports a main panel, an overhead and a left side panel, the struc­ture of the overloaded ''clbkLoadPanel'' could look like this:

bool MyVessel::clbkLoadPanel (int id)

{

switch (id) {

case 0: <span style="color:#808080;">// main panel</span>

oapiRegisterPanelBackground (LoadBitmap (hDLL,

MAKEINTRESOURCE (IDB_PANEL0)));

oapiSetPanelNeighbours (2, -1, 1, -1);

<span style="color:#808080;">// register areas for panel 0 here</span>

break;

case 1: <span style="color:#808080;">// overhead panel</span>

oapiRegisterPanelBackground (LoadBitmap (hDLL,

MAKEINTRESOURCE (IDB_PANEL1)));

oapiSetPanelNeighbours (-1, -1, -1, 0);

<span style="color:#808080;">// register areas for panel 1 here</span>

break;

case 2: <span style="color:#808080;">// left side panel</span>

oapiRegisterPanelBackground (LoadBitmap (hDLL,

MAKEINTRESOURCE (IDB_PANEL2)));

oapiSetPanelNeighbours (-1, 0, -1, -1);

<span style="color:#808080;">// register areas for panel 2 here</span>

break;

}

return true;

}

Each panel must register its own background bitmap via the ''oapiRegisterPanelBack­ground'' function.

In a vessel that defines multiple panels, the user can switch between them by using Ctrl-Ar­row keys. SpaceXpanse must know the relative location of bitmaps to each other, so that the correct panel can be loaded. This connectivity is provided by the ''oapiSet­PanelNeighbours'' function. This function tells SpaceXpanse which panels are to the left, right, top and bottom of the current panel. A value of –1 indicates that no panel is lo­cated at that side.

'''Important''': All the panel id’s defined during ''oapiSetPanelNeighbours'' must be sup­ported by ''clbkLoadPanel''. For example, if panel 0 calls ''oapiSetPanelNeighbours (2,-1,1,-1)'', then panels 1 and 2 must be handled by ''clbkLoadPanel''.

All panels must call the ''oapiSetPanelNeighbours'' function, otherwise there is no way for the user to switch back to a different panel. Panel connectivities should usually be reciprocal, i.e. if panel 0 defines panel 1 as its top neighbour, then panel 1 should de­fine panel 0 as its bot­tom neighbour. If only a single panel (panel 0) is supported, calling ''oapiSetPanelNeighbours'' is not necessary.

== {{anchor|Ref83591077}} {{anchor|RefHeadingToc271829944}} Designing virtual cockpits ==

The concepts used for defining virtual 3-D cockpits are similar to those of 2-D panels. They too are defined via a load function, mouse and redraw event handlers. In fact, some of the re­draw methods defined for panel areas may be reused to update parts of the virtual cockpit textures, so it is useful to familiarise yourself with 2-D panel im­plementations before pro­gressing to virtual cockpits.

=== Defining a virtual cockpit ===

A virtual cockpit requires a 3-D mesh representation. In principle it is possible to add the cockpit directly to the mesh used to represent the vessel in external views, and flag this mesh to be visible both in external and cockpit views (via the ''SetMeshVisi­bility'' method), but in gen­eral it is more efficient to design a separate mesh for the cockpit which is visible only in virtual cock­pit view mode (using ''SetMeshVisibility'' with the ''MESHVIS_VC'' flag). Make sure that the cockpit mesh is consistent with the external mesh. A good way to achieve this is by building the VC together with the ex­ternal mesh in your 3D design program, but exporting the cockpit and the external parts to separate mesh files.


[[Image:Image12.png|top]]

''Figure 3: A view of the SC virtual cockpit.''

To make the VC mode available in your mesh class, you must overload the ''clbkLoadVC ''method of the ''VESSEL2'' class:

bool MyVessel::clbkLoadVC (int id)

{

<div style="color:#808080;">...</div>

}

This will allow the user to switch to VC mode with the F8 key. The ''id'' parameter is currently always 0. Eventually it will allow to select different cockpit positions.

In the body of ''clbkLoadVC'', you can define camera parameters:

<div style="color:#808080;">bool MyVessel::clbkLoadVC (int id)</div>

<div style="color:#808080;">{</div>

SetCameraOffset (_V(0,1.5,6.0));

SetCameraDefaultDirection (_V(0,0,1));

SetCameraRotationRange (RAD*120, RAD*120, RAD*70, RAD*70);

SetCameraShiftRange (_V(0,0,0.1), _V(-0.2,0,0), _V(0.2,0,0));

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

''SetCameraOffset'' defines the camera (or pilot eye) position in the vessel coordinate frame. ''SetCameraDefaultDirection'' defines the default direction the pilot is looking toward, ''SetCam­eraRotationRange'' defines how far he can turn his head left right, up and down, and ''SetCam­eraShiftRange'' allows to simulate the pilot 'leaning' forward, left or right, for example to get a better view out of a window.

Note that you only need to define these camera parameters here if they change be­tween dif­ferent cockpit view modes. If all camera modes use the same parameters, they can be de­fined globally in the overloaded ''clbkSetClassCaps'' method.

Once you have implemented the ''clbkLoadVC'' method thus far and defined the VC mesh, you should be able to compile the module and test the virtual cockpit mode in SpaceXpanse. Try rotating the view with Alt+cursor keys, and 'leaning' with Ctrl+Alt+cursor keys. When you are satisfied with the camera parameters, you can proceed to activate VC areas.

=== Defining active VC areas ===

As with 2-D panels, virtual cockpit areas must be activated to allow dynamic updates or to respond to user input. This is how an active area is defined in ''clbkLoadVC'':

<div style="color:#808080;">bool MyVessel::clbkLoadVC (int id)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

SURFHANDLE tex = oapiGetTextureHandle (vcmesh, 10);

oapiVCRegisterArea (AID_BUTTON, _R(0,0,20,10), PANEL_REDRAW_ALWAYS, 

PANEL_MOUSE_LBDOWN, PANEL_MAP_BGONREQUEST, tex);

oapiVCSetAreaClickmode_Spherical (AID_BUTTON, _V(5,3.3,7.1), 2.5);

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

As with 2-D panel area definitions, the first parameter of ''oapiVCRegisterArea'' defines a unique identi­fier for the area (''AID_BUTTON'' in this case). The next parameter de­fines a rec­tangular area (in pixel units) in a texture that is updated dynamically in a redraw event. If the area doesn't need to update any textures (e.g. because it only re­sponds to mouse events, or because it provides visual feedback by modifying the mesh geometry), this parameter is ig­nored and can be set to _R(0,0,0,0). 

The third parameter defines the events which trigger a redraw notification for the area. In this case we have set it to ''PANEL_REDRAW_ALWAYS'', i.e. we request a re­draw notification at each simulation frame (typical for gauges whose displays change constantly). Note that unlike 2-D panels, the term 'redraw event' stands for any change in the visual representation of the area. This may consist of repainting a dy­namic texture, but it could also mean a mesh group animation or direct editing of mesh vertices or texture coordinates.

The fourth parameter defines the mouse events which trigger a notification for the area. They are used in the same way as 2-D panel areas, but an additional function call is required to de­fine the mouse-sensitive area (see below).

The fifth parameter defines the initial contents of the drawing bitmap passed to the redraw notification. It is used in the same way as for 2-D panels. However, if the re­draw event does not update a dynamic texture, this ''must'' be set to ''PANEL_MAP_NONE''.

The last parameter is a handle to the dynamic texture passed to redraw notifications. In this example, we have obtained the texture handle from mesh group 10 of the VC mesh via a call to ''oapiGetTextureHandle''. Note that textures obtained for dynamic re­painting must be labelled as dynamic in the mesh file (see next section). If the area does not need to redraw a texture during a redraw event, this parameter can be set to ''NULL''. In that case, there is a shorter ver­sion of ''oapiVCRegisterArea'' for convenience which omits the second, fifth and sixth parame­ters.

Unlike 2-D panels, the mouse-sensitive region of a VC area must be defined with a separate function call. In virtual cockpits, the sensitive region is a 3-D volume. SpaceXpanse draws a virtual ray from the camera position through the screen point at which a mouse event occurred, and checks whether the ray intersects a mouse-sensitive vol­ume. If so, the corresponding mouse event is generated.

You can define either a spherical or a quadrilateral mouse-sensitive region. A spheri­cal region is defined via the ''oapiVCSetAreaClick­mode_Spherical'' method, where you specifiy the centre of the spherical region in the vessel frame of reference, and its ra­dius. This will trigger a mouse event whenever the user clicks inside the projection of the sphere onto the simulation window.

Quadrilateral (e.g. rectangular) regions are defined via the ''oapiVCSetAreaClick­mode_Quadrilateral method'', where you specify the four corners of the mouse-sensi­tive re­gion in space. Again, this will trigger mouse events whenever the user clicks in­side the pro­jection of the sensitive area on the simulation window.

Spherical regions are slightly more efficient for SpaceXpanse to test, but quadrilateral re­gions return information about the relative position at which the mouse click oc­curred, so they are some­what more versatile.

=== Defining dynamic textures ===

One way to provide information to the pilot in VC mode is by repainting the bitmaps used to texture VC mesh groups. For example, you can implement gauges and data displays in this way. You may even be able to re-use a panel area redraw method used for 2-D panels to up­date a VC texture, minimising the additional coding effort.

'''Important''': SpaceXpanse can only draw into uncompressed textures. For this reason, textures which support dynamic repainting must be marked in the mesh file with a 'D' (''dynamic''), e.g.

...

Textures 2

tex1.dds

tex2_dyn.dds D

Dynamic textures are less efficient than static ones, so you should try to keep them to a minimum. Collect all parts that require dynamic updates in one or few (small) tex­ture files, and keep them apart from the static parts.

=== The mouse event handler ===

Whenever a mouse event occurs inside the mouse-sensitive volume of an active area, a notification is passed to your module. To respond to such events, you must overload the ''clbkVCMouseEvent'' method of the ''VESSEL2'' class.

bool MyVessel::clbkVCMouseEvent (int id, int event, VECTOR3 &p)

{

...

}

where ''id'' is the area identifier, and ''event'' is the mouse event that triggered the notifi­cation (The VC notification uses the same event types as 2-D panels).

Parameter ''p'' returns some information about the mouse position at the event. The information returned depends on the area type for which the event was generated. For spherical regions, p.x contains the distance of the mouse position from the centre of the area, while p.y and p.z are not used. For quadrilateral regions, ''p.x'' and ''p.y'' contain the relative mouse x and y posi­tions within the region, where the top left cor­ner of the region has coordinates (0,0), and the bottom right corner has coordinates (1,1). This allows to define differentiated responses de­pending on where in the region the event occurred, similar to the procedure in 2-D panel re­gions.

Inside ''clbkVCMouseEvent'', your code must check the area id and perform the appro­priate actions:

<div style="color:#808080;">bool MyVessel::clbkVCMouseEvent (int id, int event, VECTOR3 &p)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (id) {</div>

case AID_BUTTON:

DoProcessButtonPress (...);

return true;

<div style="color:#808080;">case ... // place response to other areas here</div>

<div style="color:#808080;">}</div>

<div style="color:#808080;">return false;</div>

<div style="color:#808080;">}</div>

=== The redraw event handler ===

Any active areas which specified a redraw flag other than ''PANEL_REDRAW_NEVER'' during initialisation, will trigger redraw notifications for the appropriate events. Your code needs to overload the ''clbkVCRedrawEvent'' method of the ''VESSEL2'' class to re­spond to those events.

bool MyVessel::clbkVCRedrawEvent (int id, int event, SURFHANDLE surf)

{

...

}

where ''id'' is the area identifier, ''event'' is the redraw event that triggered the notifica­tion, and ''surf'' is a handle to the dynamic texture to be redrawn. ''surf'' may be ''NULL'' if you didn't specify a texture during the area initialisation.

Inside ''clbkVCRedrawEvent'', check the area id and perform the appropriate redraw action for that area. Typically, this will be one of the following:* Repainting the dynamic texture passed to the notification handler. This is done in the same way as repainting 2-D panel areas. In fact, you may even be able to re-use the same code. Repainting textures is a good way to update displays and in­strument gauges.
* Animating a mesh group. This can be used to simulate flipping a switch or push­ing a lever. See Section 1.10for details on animations.
* Editing a mesh. You can use the ''oapiMeshGroup'' function to access the vertices of a mesh group, and edit the vertex positions or texture coordinates. Editing tex­ture co­ordinates may be a good alternative to redrawing a texture if the texture is to switch between discrete pre-defined states.



''clbkVCRedrawEvent'' should return ''true'' only if you have modified the dynamic tex­ture. If the texture was not modified, or is undefined, the function should return ''false''.

=== Defining MFDs in the virtual cockpit ===

To define a multifunctional display inside a virtual cockpit, you need to perform the following steps:

Create a new group in the mesh consisting of a flat square area (defined by 4 vertices and 2 triangles). This is going to be the MFD display. The texture coordinates of the vertices should be: top left corner: (0,0), top right corner: (1,0), bottom left corner: (0,1) and bottom right cor­ner: (1,1). Set 'TEXTURE 0' and 'FLAG 3' for this group. This will exclude the group from normal rendering (SpaceXpanse uses a special render pass for MFDs). You can select a material of your choice. A material with specular reflec­tion will produce a 'glass surface' effect.

In ''clbkLoadVC'', define the MFD display with ''oapiVCRegisterMFD'':

<div style="color:#808080;">bool MyVessel::clbkLoadVC (int id)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

static VCMFDSPEC mfds_left <nowiki>= {1, 100};</nowiki>

oapiVCRegisterMFD (MFD_LEFT, &mfds_left);

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

''VCMFDSPEC'' is a structure which contains the mesh index and group index of the MFD dis­play group defined in the previous step. ''oapiVCRegisterMFD'' registers this group as an MFD display (in this case, the left MFD).

Next, you need to define the MFD control buttons. How you implement them is mostly up to you. Typically, you define each button as a rectangle and collect all rec­tangles into a single mesh group. Reserve space on a dynamic texture for drawing the button labels, and set the texture coordinates for the button rectangles accordingly.

Then you define an active area for each button to receive mouse events (but no re­draw events). You also define a dummy area for redraw events. Pass the dynamic texture handle reserved for that purpose to the redraw area. This could look as fol­lows:

<div style="color:#808080;">bool MyVessel::clbkLoadVC (int id)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">...</div>

oapiVCRegisterArea (AID_LBUTTONS, _R(0,0,20,100),PANEL_REDRAW_USER,

PANEL_MOUSE_IGNORE, PANEL_MAP_BACKGROUND, tex);

oapiVCRegisterArea (AID_RBUTTONS,_R(20,0,40,100), PANEL_REDRAW_USER,

PANEL_MOUSE_IGNORE, PANEL_MAP_BACKGROUND, tex);

for (i = 0; i < 6; i++) {

oapiVCRegisterArea (AID_LBUTTON1+i, PANEL_REDRAW_NEVER,

PANEL_MOUSE_LBDOWN|PANEL_MOUSE_LBPRESSED);

oapiVCSetAreaClickmode_Spherical (AID_LBUTTON1+i,

_V(0.2,0.1-i*0.02,2.0), 0.01);

oapiVCRegisterArea (AID_RBUTTON1+i, PANEL_REDRAW_NEVER,

PANEL_MOUSE_LBDOWN|PANEL_MOUSE_LBPRESSED);

oapiVCSetAreaClickmode_Spherical (AID_RBUTTON1+i,

_V(0.4,0.1-i*0.02,2.0), 0.01);

}

<div style="color:#808080;">...</div>

<div style="color:#808080;">}</div>

You should also define mouse-active areas for the three bottom MFD buttons.

In the mouse event handler, trap any mouse clicks on the MFD buttons and pass them to the ''oapiProcessMFDButton'' function:

<div style="color:#808080;">bool MyVessel::clbkVCMouseEvent (int id, int event)</div>

<div style="color:#808080;">{</div>

if (id >= AID_LBUTTON1 && id < AID_LBUTTON1+12) {

oapiProcessMFDButton (MFD_LEFT, id-AID_LBUTTON1, event);

return true;

}

<div style="color:#808080;">...</div>

<div style="color:#808080;">return false;</div>

<div style="color:#808080;">}</div>

In the redraw event handler, trap MFD button redraw requests and redraw the but­tons as re­quired:

<div style="color:#808080;">bool MyVessel::clbkVCRedrawEvent (int id, int event, SURFHANDLE surf)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (id) {</div>

case AID_LBUTTONS:

RedrawMFDButtons (surf, MFD_LEFT, 0);

return true;

case AID_RBUTTONS:

RedrawMFDButtons (surf, MFD_RIGHT, 0);

return true;

<div style="color:#808080;">case ...</div>

<div style="color:#808080;">}</div>

where ''RedrawMFDButtons'' is assumed to be a locally defined function performing the redraw action. You may be able to re-use the same method used for drawing the MFD buttons in the 2-D panel (see Section 1.12.5).

Finally, trigger a redraw event in the body of the MFD mode change callback notifi­cation.

<div style="color:#808080;">void MyVessel::MFDMode (int mfd, int mode)</div>

<div style="color:#808080;">{</div>

<div style="color:#808080;">switch (mfd) {</div>

case MFD_LEFT:

oapiTriggerVCRedrawArea (0, AID_LBUTTONS);

oapiTriggerVCRedrawArea (0, AID_RBUTTONS);

break;

<div style="color:#808080;">case ...</div>

<div style="color:#808080;">}</div>

=== Defining the HUD in the virtual cockpit ===

< to be completed >


= {{anchor|RefHeadingToc271829945}} Planets and moons =

SpaceXpanse allows to create new planets or planetary systems in a few simple steps. To create a new planet, you need to do the following:* find or create a surface texture map
* optionally, find or create texture maps for a cloud layer, for a land/sea mask, and for night lights
* convert the texture map(s) into SpaceXpanse’s .tex format by invoking pltex
* create a configuration file (.cfg) in the Config subfolder, containing physical and or­bital planet parameters.
* Add an entry for the planet in the configuration file of the planetary system (e.g. Sol.cfg).
* Optionally, create a DLL plugin module to allow detailed control of planet move­ment and atmosphere definition.



== {{anchor|RefHeadingToc271829946}} Planet texture maps ==

=== Texture format ===

Each planet has an associated surface texture file <''pname''>.tex, where <''pname''> is the planet’s name. Optionally, additional texture files <''pname''>_cloud.tex (for de­fining a cloud layer), <''pname''>_lmask.tex (for defining a land area mask) and <''pname''>_lights.tex (for defining surface night lights) may be present.

Each texture file contains a series of texture maps, stored as DirectDraw surfaces (dds) in DXT1 compression format.

SpaceXpanse uses a variable resolution approach for both meshes and texture maps to render planetary surfaces. The rendering resolution level is determined by the appar­ent radius of the planet. At low resolutions SpaceXpanse uses a single spherical mesh covered by a single texture. At higher resolutions the spherical surface is constructed from a series of sphere patches, each containing its own texture patch. This method allows efficient rendering by removing hidden patches before invoking the rendering pipeline.

SpaceXpanse currently supports 9 resolution levels for planetary surfaces, as listed in Table 1. At the highest resolution the sphere is constructed from 364 patches with an effective texture resolution of 16384x8192. Figure 4shows a detail of the Martian sur­face rendered at different resolution levels.


{| style="border-spacing:0;width:5.8083in;"
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Level
|| Resolution*
|| Mesh patches
|| Triangles (total)**
| colspan="2"  align=center| Texture memory***
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
| align=right| with DXT1
| align=right| w/o DXT1
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 1
| align=right| 64 x 64
| align=right| 1
| align=right| 144
| align=right| 2K
| align=right| 16K
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 2
| align=right| 128 x 128
| align=right| 1
| align=right| 256
| align=right| 10K
| align=right| 80K
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 3
| align=right| 256 x 256
| align=right| 1
| align=right| 576
| align=right| 42K
| align=right| 336K
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 4
| align=right| 512 x 256
| align=right| 2
| align=right| 1024
| align=right| 106K
| align=right| 848K
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 5
| align=right| 1024 x 512
| align=right| 8
| align=right| 2592
| align=right| 362K
| align=right| 2.9M
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 6
| align=right| 2048 x 1024
| align=right| 24
| align=right| 4672
| align=right| 1.1M
| align=right| 9.0M
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 7
| align=right| 4096 x 2048
| align=right| 100
| align=right| 25440
| align=right| 4.3M
| align=right| 34.6M
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 8
| align=right| 8192 x 4096
| align=right| 364
| align=right| 116448
| align=right| 16.0M
| align=right| 127.8M
|- style="border:0.5pt solid #000000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| 9
| align=right| 16384 x 8192
| align=right| 1456
| align=right| 276640
| align=right| 63.9M
| align=right| 511.2M
|-
|}
{{anchor|Ref508476254}} ''Table 1: Supported resolution levels for planetary surfaces.''

<nowiki>*Resolution: Effective texture map resolution at the equator.</nowiki>

<nowiki>**Triangles: This is the total number of triangles for all patches. In practice fewer tri­angles will be rendered because hidden patches are removed before entering the ren­dering pipeline.</nowiki>

<nowiki>***Texture memory: Video/AGP memory required to hold texture maps up to this resolution level for a single planet. With DXT1: video hardware supports DXT1 tex­ture compression. W/o DXT1: video hardware doesn’t support DXT1 texture com­pression.</nowiki>

High resolution levels require significant amounts of video/AGP memory and should only be used on systems with adequate 3D graphics subsystems. On older graphics cards which do not natively support DXT1 texture compression SpaceXpanse needs to convert textures into RGBA format which increases memory requirements 8-fold. Conversion to RGBA will also dramatically increase the loading time when starting SpaceXpanse.


{| style="border-spacing:0;width:6.4979in;"
|-
| style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | [[Image:Image13.png|top]][[Image:Image14.png|top]]
| style="border:0.5pt solid #ff0000;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;" | '''Important''': Do not try to use resolution level  8 if your video card does not sup­port DXT1 texture compression or has less than 32MB of texture memory!
|-
|}


[[Image:Image15.png|top]][[Image:Image16.png|top]][[Image:Image17.png|top]][[Image:Image18.png|top]]

{{anchor|Ref508549157}} ''Figure 4: Mars texture detail at resolution levels 5, 6, 7 and 8 (from left).''

=== Where SpaceXpanse looks for textures ===

SpaceXpanse first searches for the texture file in the location specified by the HightexDir entry in the ''SpaceXpanse.cfg'' file. If the texture file is not found or if HightexDir is not defined then SpaceXpanse searches in the directory specified by the TextureDir entry. This allows switching between high and low resolution texture maps conveniently by inserting or removing the HightexDir entry.

If no texture file is found then the planet is rendered without a surface texture.

Each planet’s configuration file <''pname''>.cfg contains an entry ''MaxPatchResolution'' which defines the maximum texture resolution level to use with this planet (valid range 1 to 8). If the texture file contains higher resolution levels than defined by ''MaxPatchResolution'' then the additional resolutions are skipped. This allows reduc­ing texture memory requirements without modifying the texture file. If the texture file contains fewer resolution levels than defined by ''MaxPatchResolution'' then the maximum resolution is reduced accordingly.

=== Using pltex to generate custom planet textures ===

If you prefer, you can use your own planet maps instead of those provided by SpaceXpanse. The SpaceXpanse download page contains a planet texture conversion tool (''pltex'') which allows to convert planet maps from BMP bitmap format to SpaceXpanse’s texture format. It resamples the map to the requested resolutions, splits it into sur­face patches and converts them to DXT1 compressed texture format.

The source map should contain the complete surface in spherical projection, where the left edge corresponds to longitude 180°W, the right edge to longitude 180°E, the bottom edge to latitude 90°S, and the top edge to latitude 90°N. The width/height ratio of the bitmap should be close to 2/1.

Pltex requires the source map in 24bit or 8bit Windows BMP format. If your map is in any other format (e.g. JPEG or GIF) you need to convert it into BMP (using your favourite graph­ics conversion tool) before invoking pltex.

Synopsis:

pltex [–i <''mapname''>] [-l <''minres''> -h <''maxres''>] [-9]

''<mapname>:'' source texture file name

''<minres>:'' minimum resolution level (1..8)

''<maxres>:'' maximum resolution level ''(<minres>..''8)* If command line options are omitted then pltex requests values interactively.
* If a higher maximum resolution is requested than can be obtained from the source map, pltex adjusts the maximum resolution accordingly. See Table 1for map resolutions at the various resolution levels.
* The only justification for <''minres''> 1 is if you want to compose certain resolu­tion levels from a different source map, e.g. generate Earth resolution levels 1 to 7 from a map that includes clouds, and level 8 from a map without clouds. In that case pltex must be run twice, and the output texture files concatenated.
* The option to use alpha (transparency) maps is intended for semi-transparent cloud maps.
* You can use pltex to generate a set of level 9 texture patches by specifying the –9 command line option. In that case, both ''<minres>'' and ''<maxres>'' must be set to 9. Note that level 9 textures are treated differently to levels 1-8. Level 9 is not automatically assembled into the <planet>.tex file. Instead, after generating the individual patches (1456 in total!) with pltex, you need to run the TileManager application bundled with the SpaceXpanse base package to add patches into the <''planet''>_tile.tex file containing high-resolution patches. See the TileManager help file for details.



Pltex will generate a texture file <''mapname''>.tex. If necessary, rename to <''pname''>.tex where <''pname''> is the planet’s name, and copy to the ''TextureDir'' di­rectory (usually “Textures”) or ''HightexDir'' directory (usually “Textures2”).

<u>Note:</u>

Generating high-resolution texture maps (level 8 and higher) may take a long time and requires a large amount of system memory.

== {{anchor|Ref223633291}} {{anchor|RefHeadingToc271829947}} Planet modules ==

Planet modules can be used to control the motion of a planet (or any other celestial body, such as a moon, the sun, or an asteroid) within the solar system. This allows to implement sophisticated analytic ephemerides solutions which take into account perturbations from other celestial objects.

Planets which are not controlled via a DLL module are updated directly by SpaceXpanse. Depending on the settings in the definition file, SpaceXpanse either uses an unperturbed 2-body approximation, result­ing in a conic section trajectory (e.g. an ellipse), or uses a dynamic update procedure based on the gravitational forces acting on the planet. Both methods have limitations: the 2-body approach ignores perturbations and is only valid if no massive bodies other than the orbit ref­erence object are nearby. The dynamic update accumulates numerical errors over time, causing the orbits slowly to diverge from the correct trajectories.

By using a planet module, analytic perturbation solutions can be used which avoid the short­comings of the methods described above. Perturbation solutions typically describe the per­turbed orbit of a planet by expressing the state vectors as a trigono­metric series. These series are valid over a limited period of time, after which they start to diverge. Examples of perturba­tion solutions used in SpaceXpanse are the VSOP87 solution for the 8 major planets and the sun, or the ELP2000 solution for the moon.

Planet modules can also define an atmosphere model for the celestial body. Atmos­phere models return atmospheric data (temperature, density and pressure) at a specified altitude (and other optional parameters, such as geographic position and time). Atmospheric models can be implemented either directly in the planet module, or in a separate plugin module. Putting the atmosphere model into a separate plugin makes it easier to swap models later.

The following sections give a brief introduction into the design of planet modules. A general knowledge of writing SpaceXpanse plugins is assumed.

=== First steps ===

Create a new DLL project for your planet module, e.g. in ''SpaceXpansesdk\samples\MyPlanet''. Set up all the usual include and library paths for SpaceXpanse plugins. Add ''SpaceXpanse.lib'' and ''SpaceXpansesdk.lib'' as additional dependencies.

=== The CELBODY2 interface class ===

The communication between the SpaceXpanse core and the planet module is performed via callback functions defined in the ''CELBODY'' and ''CELBODY2'' classes. (''CELBODY2'' is derived from ''CELBODY'' and contains all the properties of the base class, plus a sig­nificantly extended atmospheric parameter interface.) The ''CELBODY'' interface is retained for backward compatibility, but all new planet modules should refer to the ''CELBODY2'' interface.

We now need to the class interface for the new planet module by deriving a custom class from ''CELBODY2''. Create a new header file in your project, e.g. ''MyPlanet.h'', and add the following:

<nowiki>#include "SpaceXpanseAPI.h"</nowiki>

<nowiki>#include "CelbodyAPI.h"</nowiki>


class DLLEXPORT MyPlanet: public CELBODY2 {

public:

MyPlanet (OBJHANDLE hObj);

void clbkInit (FILEHANDLE cfg);

int clbkEphemeris (double mjd, int req, double *ret);

int clbkFastEphemeris (double simt, int req, double *ret);

};

''SpaceXpanseAPI.h'' contains the general API interface, and ''CelbodyAPI.h'' contains the planet mod­ule-specific interface, in particular the ''CELBODY'', ''CELBODY2'' and ''AT­MOSPHERE'' classes.

The ''clbkEphemeris'' and ''clbkFastEphemeris'' methods are callback functions which SpaceXpanse will call whenever the planet positions and velocities ("ephemerides") need to be updated. They will be described in more detail below. The clbkInit method is called by SpaceXpanse after the planet module has been loaded. It receives a file handle for the planet's configuration file. This allows the module to read configuration parame­ters from the file.

The ''CELBODY2'' interface contains a few more methods related to defining an atmos­pheric model. These will be discussed below. Check the API Reference manual for a complete list of class methods. 

To implement the methods in our ''MyPlanet'' class, create a source file in your project, e.g. ''MyPlanet.cpp''. Add the following lines:

<nowiki>#define SpaceXpanse_MODULE</nowiki>

<nowiki>#include "MyPlanet.h"</nowiki>


MyPlanet::MyPlanet (OBJHANDLE hObj): CELBODY2 (hObj)

{

<span style="color:#808080;">// add constructor code here</span>

}


void MyPlanet::clbkInit (FILEHANDLE cfg)

{

<div style="color:#808080;">// read parameters from config file (e.g. tolerance limits, etc)</div>

<div style="color:#808080;">// perform any required initialisation (e.g. read perturbation terms from data files)</div>

}


bool MyPlanet::bEphemeris() const

{

return true;

<span style="color:#808080;">// class supports ephemeris calculation</span>

}


int clbkEphemeris (double mjd, int req, double *ret)

{

<span style="color:#808080;">// return planet position and velocity for Modified Julian date mjd in ret</span>

}


int clbkFastEphemeris (double simt, int req, double *ret)

{

<span style="color:#808080;">// return interpolated planet position and velocity for simulation time simt in ret</span>

}

The first line defining ''SpaceXpanse_MODULE'' is required to ensure that all initialisation functions are properly called by SpaceXpanse.

''clbkEphemeris'' and ''clbkFastEphemeris'' are the functions which will contain the actual ephemeris calculations for the planet at the requested time. ''clbkEphemeris'' is only called by SpaceXpanse if the planet’s state at an arbitrary time is required (for example by an instrument calculating the position at some future time). When SpaceXpanse updates the planet’s position for the next simulation time frame, the ''clbkFastEphemeris'' function will be called instead. This means that ''clbkFastEphemeris'' will be called at each frame, each time advancing the time by a small amount. This can be used for a more efficient calculation. Instead of performing a full series evaluation, which can be lengthy, you may implement an interpolation scheme which performs the full calcu­lation only occasionally, and interpolates between these samples to return the state at an intermediate time.

For both functions, the requested type of data is specified as a group of ''EPHEM_xxx'' bitflags in the ''req'' parameter. This can be any combination of position and velocity data for the celesital body itself and/or the barycentre of the system defined by the body and all its children (moons). The functions should calculate all required data, either in cartesian or polar coordinates, and fill the ''ret'' array with the results. ''ret'' contains 12 entries, used as follows:

<div style="margin-left:0.3937in;margin-right:0in;">''ret[0-2]'':true position</div>

<div style="margin-left:0.3937in;margin-right:0in;">''ret[3-5]'':true velocity</div>

<div style="margin-left:0.3937in;margin-right:0in;">''ret[6-8]'':barycentric position</div>

<div style="margin-left:0.3937in;margin-right:0in;">''ret[9-11]'':barycentric velocity</div>

Only the fields requested by ''req'' need to be filled. In cartesian coordinates, the posi­tion fields must contain the ''x'', ''y'' and ''z'' coordinates in [m], and the velocity fields must contain the velocities d''x''/d''t'', d''y''/d''t'', d''z''/d''t'' in [m/s]. In spherical polar coordinates, the position fields must contain longitude '''' [rad], latitude '''' [rad] and radial distance ''r'' [AU], and the velocity fields must contain the polar velocities d''''/d''t'' [rad/s], d''''/d''t'' [rad/s] and d''r''/d''t'' [AU/s].

The functions should indicate the fields actually calculated via the return value. This is in particular important if not all requests could be satisified (e.g. position and ve­locity was requested, but only position could be calculated). The return value is inter­preted as a bitflag that can contain the same ''EPHEM_xxx'' flags as the ''req'' parameter. If all requests could be satisfied, it should be identical to ''req''. In addition, the return value should contain additional flags indicating the properties of the returned data, including ''EPHEM_POLAR'' if the data are returned as spherical polar coordinates, or ''EPHEM_TRUEISBARY ''if the true and barycentric coordinates are identical (i.e. the celestial body does not have child bodies).

=== The API interface ===

Next, we need to define the API interface that will allow SpaceXpanse to load an instance of the celestial body interface. This is done by implementing the ''InitInstance'' and ''ExitIn­stance'' functions in ''MyPlanet.cpp'':

DLLCKBK CELBODY *InitInstance (OBJHANDLE hBody)

{

// instance initialisation

return new MyPlanet;

}


DLLCLBK void ExitInstance (CELBODY *body)

{

// instance cleanup

delete (MyPlanet*)body;

}

''InitInstance'' and ''ExitInstance'' are called by SpaceXpanse each time an instance of the planet is loaded or discarded. There are also functions ''InitModule'' and ''ExitModule'', which are called only once per simulation run, and can be used to initialise and clean up global resources:

DLLCLBK void InitModule (HINSTANCE hModule)

{

// module initialisation

}


DLLCLBK void ExitModule (HINSTANCE hModule)

{

// module cleanup

}

Because usually only a single instance of a specific planet object is created during a simulation, the difference between ''InitInstance'' and ''InitModule'' is not as significant here as it is for vessel modules. The ''InitModule'' and ''ExitModule'' methods can be omitted if the module doesn’t need any global parameter initialisation.

== {{anchor|RefHeadingToc271829948}} Defining an atmosphere ==

Planetary atmospheres have a significant influence on the flight behaviour of space­craft. The primary atmospheric parameters are temperature, pressure and density as a function of alti­tude.

Defining a simple atmospheric model is possible by setting a few parameters in the planet’s configuration file. More sophisticated models must be coded in the planet’s DLL module.

SpaceXpanse currently does not model local atmospheric perturbations (climatic/weather effects), although local temperature and pressure variations can be implemented by customised at­mosphere models.

=== A simple atmosphere ===

To define a simple exponentially decaying atmosphere, define the following items in the planet’s configuration (.cfg) file:

<div style="margin-left:1.5752in;margin-right:0in;">''AtmPressure0'':The static atmospheric pressure [Pa] at altitude zero, ''p''<sub>0</sub>.</div>

<div style="margin-left:1.5752in;margin-right:0in;">''AtmDensity0'':The atmospheric density [kg/m<sup>3</sup>] at altitude zero, ''''<sub>0</sub>.</div>

<div style="margin-left:1.5752in;margin-right:0in;">''AtmAltLimit'':The altitude above which atmospheric effects can be ne­glected.</div>

where altitude zero is defined as distance ''Size'' (as defined in the configuration file) from the planet’s centre.

The pressure and density at any altitude h is then calculated by SpaceXpanse as

<div style="text-align:center;"><math>p=\lbrace \begin{array}{cc}{p}_{0}{e}^{-\text{Ch}}& 	\text{if}\text{h}< \text{AtmAltLimit}\\ 
0& 	\text{otherwise}\end{array},\phantom{\rule{2em}{0ex}}\rho =\lbrace \begin{array}{cc}{\rho }_{0}{e}^{-\text{Ch}}& 	\text{if}\text{h}< \text{AtmAltLimit}\\ 
0& 	\text{otherwise}\end{array}</math></div>

where <math>C=\frac{{\rho }_{0}}{{p}_{0}}{g}_{0}</math>, and ''g''<sub>0</sub> is the gravitational acceleration at altitude zero.

This model assumes constant temperature.

=== A more sophisticated atmosphere ===

Where the simple model described above is not adequate, a more detailed atmos­pheric model can be implemented in a plugin module. This section assumes that a module for the celestial body has already been created, as outlined in Section 2.2.

The atmosphere model interface is described by the ''ATMOSPHERE'' class defined in ''Celbo­dyAPI.h''. To create a custom atmosphere model, create a new header file in your planet proj­ect, e.g. ''MyAtmosphere.h''. The atmosphere class interface should look like

<nowiki>#include "SpaceXpanseAPI.h"</nowiki>

<nowiki>#include "CelbodyAPI.h"</nowiki>


class DLLEXPORT MyAtmosphere: public ATMOSPHERE {

public:

MyAtmosphere (CELBODY2 *body);

const char *clbkName () const;

bool clbkConstants (ATMCONST *atmc) const;

bool clbkParams (const PRM_IN *prm_in, PRM_OUT *prm_out);

};

The constructor takes the ''CELBODY2'' class instance of the associated celestial body as a pa­rameter.

The ''clbkName'' callback function should return a short name identifying the model.


The ''clbkConstants'' callback function should return in atmc some basic atmosphere parame­ters, such as the mean density and pressure at ground level, gas constant and ratio of spe­cific heats, as well as some rendering parameters.

Note that some of the parameters returned by ''clbkConstants'' may be overwritten by the set­tings defined in the celestial body's configuration file. Configuration file entries take prece­dence over ''clbkConstants''.

The ''clbkParams'' callback function should return atmospheric temperature, density and pres­sure at the location specified by the data in the ''prm_in'' parameter. Simple models may de­pend on altitude only, but more sophisticated models can make use of the additional pa­rameters such as position (longitude and latitude), solar flux, geo­magnetic index, and date.

Create a source file, e.g. ''MyAtmosphere.cpp'', to implement the actual model. A very simplistic implementation may look like this:

<nowiki>#include "MyAtmosphere.h"</nowiki>


static double T0 <nowiki>= 288.0; </nowiki>// ground level temperature [K]

static double p0 <nowiki>= 101325; // ground level pressure [Pa]</nowiki>

static double rho0 <nowiki>= 1.2250; // ground level density [kg/m^3]</nowiki>

static double R <nowiki>= 286.91; // gas constant</nowiki>

static double gamma <nowiki>= 1.4; </nowiki>// ratio of specific heats

static double altlimit = 200e3; // cutoff altitude

static double C <nowiki>= rho0/p0;</nowiki>


MyAtmosphere::MyAtmosphere (CELBODY2 *body): ATMOSPHERE (body)

{

}


const char *MyAtmosphere::clbkName () const

{

static char *name = "Simple";

return name;

}


bool MyAtmosphere::clbkConstants (ATMCONST *atmc) const

{

atmc->p0 <nowiki>= p0;</nowiki>

atmc->rho0 <nowiki>= rho0;</nowiki>

atmc->R <nowiki>= R;</nowiki>

atmc->gamma <nowiki>= gamma;</nowiki>

atmc->altlimit = altlimit;

return true;

}


bool MyAtmosphere::clbkParams (const PRM_IN *prm_in, PRM_OUT *prm_out)

{

double z = (prm_in->flag & PRM_ALT ? prm_in->alt : 0.0);

if (z < 200e3) {

double scale = exp (-C*z);

prm_out->T = T0;

prm_out->rho = rho0 * scale;

prm_out->p <nowiki>= p0 </nowiki><nowiki>* scale;</nowiki>

return true;

} else {

prm_out->T <nowiki>= 0;</nowiki>

prm_out->rho = 0;

prm_out->p <nowiki>= 0;</nowiki>

return false;

}

}

The above example serves only as an illustration. The actual atmosphere models pro­vided with the SpaceXpanse distribution are more complex. For some background on the supported Earth atmosphere models, see the technical note in ''Doc\Technotes\earth_atm.pdf''.

Now we need to link the atmosphere model into the celestial body interface. This can be done with the ''SetAtmosphere'' function of the ''CELBODY2'' class. Add the following statement to the ''clbkInit'' method of your ''MyPlanet'' definition:

<nowiki>#include "MyAtmosphere.h"</nowiki>


void MyPlanet::clbkInit (FILEHANDLE cfg)

{

SetAtmosphere (new MyAtmosphere (this));

}

The atmosphere instance will be destroyed automatically when the planet instance is deleted.

=== External atmosphere modules ===

Instead of implementing the atmosphere model inside the planet module, it can can also be implemented in a separate plugin module. This makes it easier to exchange the atmosphere model for a different one later on, without having to have access to the rest of the planet module code.

To implement the atmosphere as a separate module, create a new DLL project for it. Add the ''MyAtmosphere.h'' and ''MyAtmosphere.cpp'' files created in the previous sec­tion to the project. Since the atmosphere is now defined in its own module, add the line

<nowiki>#define SpaceXpanse_MODULE</nowiki>

on top of ''MyAtmosphere.cpp''.

In addition, you need to define an API interface to the module code. It should look like this:

DLLCLBK void InitModule (HINSTANCE hModule)

{

// module initialisation

}


DLLCLBK void ExitModule (HINSTANCE hModule)

{

// module cleanup

}


DLLCLBK ATMOSPHERE *CreateAtmosphere (CELBODY2 *cbody)

{

return new MyAtmosphere (cbody);

}


DLLCLBK void DeleteAtmosphere (ATMOSPHERE *atm)

{

delete (MyAtmosphere*)atm;

}

By convention, external planetary atmosphere modules should be placed in the ''Mod­ules\Celbody\<Name>\Atmosphere'' folder, where ''<Name>'' is the celestial body's name. So in our case, ''Modules\Celbody\MyPlanet\Atmosphere\MyAtmosphere.dll''.

We now need to modify the ''MyPlanet'' code to allow it to load its atmosphere interface from an external module. Replace the ''SetAtmosphere'' statement in the ''clbkInit'' func­tion with

void MyPlanet::clbkInit (FILEHANDLE cfg)

{

LoadAtmosphereModule ("MyAtmosphere");

}

However, this causes the atmospheric module name to be hardcoded in the planet module. A more flexible method is to specify the atmospheric module in the celestial body's configuration file, using the ''MODULE_ATM'' entry. Our ''MyPlanet.cfg'' file might look like this:

NAME = MyPlanet

MODULE = MyPlanet

MODULE_ATM = MyAtmosphere

If the ''MODULE_ATM'' entry is defined in the configuration file, then the default ''CEL­BODY2::clbkInit'' implementation will load the atmosphere module directly, so we only need to make sure to call the base class method:

void MyPlanet::clbkInit (FILEHANDLE cfg)

{

CELBODY2::clbkInit (cfg);

}

Calling the ''CELBODY2::clbkInit'' method also enables another interesting feature: Before reading the ''MODULE_ATM'' entry in the planet configuration file, SpaceXpanse scans the ''Con­fig\<Name>\Atmosphere.cfg'' file for an entry "Model" and uses that, if present. This file is written by the ''Atmosphere configuration ''tool in the Extra tab of the SpaceXpanse launchpad, which provides a convenient method for users to change at­mosphere models. This mechanism al­lows to add new atmosphere modules without the need to change any configuration files. As long as the atmosphere DLL modules are placed in the correct location (''Mod­ules\Celbody\<Name>\Atmosphere''), they will be scanned automatically by the atmosphere selector tool.

=== Adding and replacing atmosphere models ===

Most of the celestial body modules in the default SpaceXpanse distribution have built-in support for external atmosphere modules, and some of them (Earth, Mars and Ve­nus) come with one or several atmosphere modules. To add additional choices for atmosphere models for a body, create one as outlined above, and simply drop the DLL library into the ''Mod­ules\Celbody\<Name>\Atmosphere'' folder. If that folder doesn't exist yet, you have to create it. The user can then select the new model from the Extra tab in the SpaceXpanse Launchpad (Celestial body configuration | Atmosphere configuration).

For best support of the atmosphere model selection tool, your atmosphere module should contain two additional API functions:

DLLCLBK char *ModelName ()

{

static char *name = "MyAtmosphere";

return name;

}


DLLCLBK char *ModelDesc ()

{

static char *desc = "My custom atmosphere model";

return desc;

}

The string returned by the ''ModelName'' function represents the model in the dialog's selection list box. The string returned by ''ModelDesc'' should contain a short descrip­tion (max 256 char­acters displayed in the dialog box when the model is selected.

If you don't want to design your own custom atmosphere model, you can quickly add atmos­pheres to planets by replicating existing ones. Simply copy an atmosphere module from the ''Modules\Celbody\<Name>\Atmosphere'' folder of one planet to that of another one. It then be­comes available in the list of atmospheres for that planet. Note that the module only provides the physical atmospheric parameters. You will still have to edit the definition file to provide visual effects.

Of course, replicating an atmosphere should be regarded as a quick and dirty trick for ex­perimentation. Atmospheres are always tailor-made for specific bodies, and don't realistically fit anywhere else.

=== Earth default atmosphere models ===

The SpaceXpanse distribution contains three Earth atmosphere models that can be selected by the user from the Extra tab in the Launchpad dialog. See ''Doc\Technotes\earth_atm.pdf'' for further details on the different models.

'''Jacchia71-Gill Atmosphere Model. '''This is an implementation of the Jacchia-71 (J71) model, using a polynomial series approximation by Gill. It uses a static US Stan­dard Atmos­phere model below 90km, and a diffusion-equilibrium solution be­tween 90 and 2500km alti­tude. The only model parameter is the exospheric tem­perature.

'''NRLMSISE-00 Atmosphere Model.''' This model is based on the MSISE90 model, with the addition of further corrections based on observation data. MSISE90 pro­vides the neutral tem­perature and density from ground level to thermospheric alti­tudes. Unlike the Jacchia models, the low-altitude data are not static, but vary with location.

'''SpaceXpanse 2006 Legacy model. '''This is the model that was used in the SpaceXpanse 2006 Edition. It is based on a static standard model below 105km, and assumes constant temperature and ex­ponentially decaying density and pressure between 105 and 200km. This model underesti­mates density and pressure above ~120km, which re­duces the orbit decay of object in low Earth orbit.

In addition, the atmosphere can be disabled for testing/debugging purposes.

=== Mars atmosphere ===

SpaceXpanse uses the following atmospheric parameter profiles for Mars:


{| style="border-spacing:0;width:5.2924in;"
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Altitude [km]
| align=right| 0
| align=right| 2
| align=right| 4
| align=right| 14
| align=right| 20
| align=right| 30
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Temperature [K]
| align=right| 195
| align=right| 200
| align=right| 200
| align=right| 180
| align=right| 180
| align=right| 165
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Pressure [Pa]
| align=right| 610.0
| align=right| 499.5
| align=right| 410.1
| align=right| 145.1
| align=right| 75.2
| align=right| 23.9
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Density [kg m<sup>-3</sup>]
| align=right| 0.02
| align=right| 0.0160
| align=right| 0.0131
| align=right| 0.0052
| align=right| 2.710<sup>-3</sup>
| align=right| 9.310<sup>-4</sup>
|-
|}
[[Image:Image19.png|top]]

[[Image:Image20.png|top]][[Image:Image21.png|top]]

Atmospheric parameters:

<div style="margin-left:2.1661in;margin-right:0in;">Surface pressure:''p''<sub>0</sub> = 610.0 Pa</div>

<div style="margin-left:2.1661in;margin-right:0in;">Surface density:''''<sub>0</sub> = 0.020 kg m<sup>-3</sup></div>

<div style="margin-left:2.1661in;margin-right:0in;">Ratio of specific heats:'''' = 1.2941</div>

<div style="margin-left:2.1661in;margin-right:0in;">Specific gas constant:''R'' = 188.92 J K<sup>-1</sup> kg<sup>-1</sup></div>

SpaceXpanse defines the upper atmosphere altitude limit as 100 km.

=== Venus atmosphere ===

SpaceXpanse uses the following atmospheric parameter profiles for Venus:


{| style="border-spacing:0;width:5.2924in;"
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Altitude [km]
| align=right| 0
| align=right| 30
| align=right| 60
| align=right| 70
| align=right| 90
| align=right| 200
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Temperature [K]
| align=right| 750
| align=right| 480
| align=right| 230
| align=right| 230
| align=right| 180
| align=right| 180
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Pressure [Pa]
| align=right| 9.2M
| align=right| 897k
| align=right| 14.2k
| align=right| 1.85k
| align=right| 18.5
| align=right| 3.410<sup>-11</sup>
|- style="border:none;padding-top:0in;padding-bottom:0in;padding-left:0.075in;padding-right:0.075in;"
|| Density [kg m<sup>-3</sup>]
| align=right| 65
| align=right| 9.9
| align=right| 0.33
| align=right| 0.043
| align=right| 5.410<sup>-4</sup>
| align=right| 1.010<sup>-15</sup>
|-
|}
[[Image:Image22.png|top]]

[[Image:Image23.png|top]][[Image:Image24.png|top]]

Atmospheric parameters:

<div style="margin-left:2.0673in;margin-right:0in;">Surface pressure:''p''<sub>0</sub> = 9.2 MPa</div>

<div style="margin-left:2.0673in;margin-right:0in;">Surface density:''''<sub>0</sub> = 65 kg m<sup>-3</sup></div>

<div style="margin-left:2.0673in;margin-right:0in;">Ratio of specific heats:'''' = 1.2857</div>

<div style="margin-left:2.0673in;margin-right:0in;">Specific gas constant:''R'' = 188.92 J K<sup>-1</sup> kg<sup>-1</sup></div>

SpaceXpanse defines the upper atmosphere altitude limit as 200 km. The cloud layer is set at an altitude of 60 km.

=== The speed of sound ===

SpaceXpanse uses the equation for an ideal gas to compute the speed of sound as a function of absolute temperature:

<div style="text-align:center;"><math>a=\sqrt{\gamma \text{RT}}</math></div>

where '''' is the ratio of specific heat at constant pressure ''c<sub>p''</sub>, and specific heat at con­stant temperature, ''c<sub>v''</sub>, for the gas, <math>\gamma ={c}_{p}/{c}_{v}</math>For air at normal conditions, '''' = 1.4. This value is used by SpaceXpanse as a default. It can be overridden by setting the AtmGamma parameter in the planet’s configuration file.

''R'' is the specific gas constant. By default, SpaceXpanse uses the value for air, 286.91 J K<sup>-1</sup> kg<sup>-1</sup>. This can be overridden by setting the ''AtmGasConstant'' parameter in the planet’s configuration file.

'''Mach number''': The Mach number is an essential parameter in aerodynamics. It ex­presses a velocity ''v'' in units of the current speed of sound:

<div style="text-align:center;">''M = v/a''</div>


= {{anchor|RefHeadingToc271829949}} References =


